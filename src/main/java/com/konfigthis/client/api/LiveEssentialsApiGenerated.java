/*
 * Vimeo API
 * Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.
 *
 * The version of the OpenAPI document: 3.4
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequest;
import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequestEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequestInteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequestSchedule;
import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequestStreamEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateEventForUserRequestStreamPrivacy;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequest;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequestEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequestInteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequestSchedule;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequestStreamEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateEventRequestStreamPrivacy;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequest;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequestEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequestInteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequestSchedule;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequestStreamEmbed;
import com.konfigthis.client.model.LiveEssentialsCreateLiveEventRequestStreamPrivacy;
import com.konfigthis.client.model.LiveEssentialsDeleteMultipleEventsRequest;
import com.konfigthis.client.model.LiveEssentialsDeleteMultipleEventsRequest1;
import com.konfigthis.client.model.LiveEssentialsDeleteMultipleEventsRequest2;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Embed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1InteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Schedule;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamEmbed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamPrivacy;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Embed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2InteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Schedule;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamEmbed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamPrivacy;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestEmbed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestInteractionToolsSettings;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestSchedule;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamEmbed;
import com.konfigthis.client.model.LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamPrivacy;
import com.konfigthis.client.model.LiveEvent;
import com.konfigthis.client.model.LiveEventRecurring;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class LiveEssentialsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public LiveEssentialsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public LiveEssentialsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createEventCall(LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsCreateEventRequest;

        // create path and map variables
        String localVarPath = "/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEventValidateBeforeCall(LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEssentialsCreateEventRequest' is set
        if (liveEssentialsCreateEventRequest == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsCreateEventRequest' when calling createEvent(Async)");
        }

        return createEventCall(liveEssentialsCreateEventRequest, _callback);

    }


    private ApiResponse<LiveEventRecurring> createEventWithHttpInfo(LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest) throws ApiException {
        okhttp3.Call localVarCall = createEventValidateBeforeCall(liveEssentialsCreateEventRequest, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createEventAsync(LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEventValidateBeforeCall(liveEssentialsCreateEventRequest, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateEventRequestBuilder {
        private final String title;
        private Boolean allowShareLink;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLang;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsCreateEventRequestEmbed embed;
        private String folderUri;
        private LiveEssentialsCreateEventRequestInteractionToolsSettings interactionToolsSettings;
        private Boolean lowLatency;
        private String playlistSort;
        private Boolean rtmpPreview;
        private LiveEssentialsCreateEventRequestSchedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsCreateEventRequestStreamEmbed streamEmbed;
        private String streamPassword;
        private LiveEssentialsCreateEventRequestStreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private CreateEventRequestBuilder(String title) {
            this.title = title;
        }

        /**
         * Set allowShareLink
         * @param allowShareLink Whether the share link is usable. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder allowShareLink(Boolean allowShareLink) {
            this.allowShareLink = allowShareLink;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords that improve the quality of the automated closed captions. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLang
         * @param autoCcLang The language in which the automated closed captions appear.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder autoCcLang(String autoCcLang) {
            this.autoCcLang = autoCcLang;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder embed(LiveEssentialsCreateEventRequestEmbed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set folderUri
         * @param folderUri The URI of the event&#39;s folder. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder folderUri(String folderUri) {
            this.folderUri = folderUri;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder interactionToolsSettings(LiveEssentialsCreateEventRequestInteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set lowLatency
         * @param lowLatency Whether the event has low-latency streaming enabled. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder lowLatency(Boolean lowLatency) {
            this.lowLatency = lowLatency;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set rtmpPreview
         * @param rtmpPreview Whether the event has RTMP preview enabled. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder rtmpPreview(Boolean rtmpPreview) {
            this.rtmpPreview = rtmpPreview;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder schedule(LiveEssentialsCreateEventRequestSchedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder streamEmbed(LiveEssentialsCreateEventRequestStreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder streamPrivacy(LiveEssentialsCreateEventRequestStreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return CreateEventRequestBuilder
         */
        public CreateEventRequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for createEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest = buildBodyParams();
            return createEventCall(liveEssentialsCreateEventRequest, _callback);
        }

        private LiveEssentialsCreateEventRequest buildBodyParams() {
            LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest = new LiveEssentialsCreateEventRequest();
            liveEssentialsCreateEventRequest.title(this.title);
            liveEssentialsCreateEventRequest.allowShareLink(this.allowShareLink);
            liveEssentialsCreateEventRequest.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsCreateEventRequest.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLang != null)
            liveEssentialsCreateEventRequest.autoCcLang(LiveEssentialsCreateEventRequest.AutoCcLangEnum.fromValue(this.autoCcLang));
            liveEssentialsCreateEventRequest.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsCreateEventRequest.chatEnabled(this.chatEnabled);
            liveEssentialsCreateEventRequest.contentRating(this.contentRating);
            liveEssentialsCreateEventRequest.dvr(this.dvr);
            liveEssentialsCreateEventRequest.embed(this.embed);
            liveEssentialsCreateEventRequest.folderUri(this.folderUri);
            liveEssentialsCreateEventRequest.interactionToolsSettings(this.interactionToolsSettings);
            liveEssentialsCreateEventRequest.lowLatency(this.lowLatency);
            if (this.playlistSort != null)
            liveEssentialsCreateEventRequest.playlistSort(LiveEssentialsCreateEventRequest.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsCreateEventRequest.rtmpPreview(this.rtmpPreview);
            liveEssentialsCreateEventRequest.schedule(this.schedule);
            liveEssentialsCreateEventRequest.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsCreateEventRequest.streamDescription(this.streamDescription);
            liveEssentialsCreateEventRequest.streamEmbed(this.streamEmbed);
            liveEssentialsCreateEventRequest.streamPassword(this.streamPassword);
            liveEssentialsCreateEventRequest.streamPrivacy(this.streamPrivacy);
            liveEssentialsCreateEventRequest.streamTitle(this.streamTitle);
            liveEssentialsCreateEventRequest.timeZone(this.timeZone);
            return liveEssentialsCreateEventRequest;
        }

        /**
         * Execute createEvent request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = createEventWithHttpInfo(liveEssentialsCreateEventRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createEvent request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest = buildBodyParams();
            return createEventWithHttpInfo(liveEssentialsCreateEventRequest);
        }

        /**
         * Execute createEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsCreateEventRequest liveEssentialsCreateEventRequest = buildBodyParams();
            return createEventAsync(liveEssentialsCreateEventRequest, _callback);
        }
    }

    /**
     * Create a live event
     * This method creates a new event for the authenticated user.
     * @param liveEssentialsCreateEventRequest  (required)
     * @return CreateEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
     </table>
     */
    public CreateEventRequestBuilder createEvent(String title) throws IllegalArgumentException {
        if (title == null) throw new IllegalArgumentException("\"title\" is required but got null");
            

        return new CreateEventRequestBuilder(title);
    }
    private okhttp3.Call createEventForUserCall(Double userId, LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsCreateEventForUserRequest;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEventForUserValidateBeforeCall(Double userId, LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling createEventForUser(Async)");
        }

        // verify the required parameter 'liveEssentialsCreateEventForUserRequest' is set
        if (liveEssentialsCreateEventForUserRequest == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsCreateEventForUserRequest' when calling createEventForUser(Async)");
        }

        return createEventForUserCall(userId, liveEssentialsCreateEventForUserRequest, _callback);

    }


    private ApiResponse<LiveEventRecurring> createEventForUserWithHttpInfo(Double userId, LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest) throws ApiException {
        okhttp3.Call localVarCall = createEventForUserValidateBeforeCall(userId, liveEssentialsCreateEventForUserRequest, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createEventForUserAsync(Double userId, LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEventForUserValidateBeforeCall(userId, liveEssentialsCreateEventForUserRequest, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateEventForUserRequestBuilder {
        private final String title;
        private final Double userId;
        private Boolean allowShareLink;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLang;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsCreateEventForUserRequestEmbed embed;
        private String folderUri;
        private LiveEssentialsCreateEventForUserRequestInteractionToolsSettings interactionToolsSettings;
        private Boolean lowLatency;
        private String playlistSort;
        private Boolean rtmpPreview;
        private LiveEssentialsCreateEventForUserRequestSchedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsCreateEventForUserRequestStreamEmbed streamEmbed;
        private String streamPassword;
        private LiveEssentialsCreateEventForUserRequestStreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private CreateEventForUserRequestBuilder(String title, double userId) {
            this.title = title;
            this.userId = userId;
        }

        /**
         * Set allowShareLink
         * @param allowShareLink Whether the share link is usable. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder allowShareLink(Boolean allowShareLink) {
            this.allowShareLink = allowShareLink;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords that improve the quality of the automated closed captions. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLang
         * @param autoCcLang The language in which the automated closed captions appear.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder autoCcLang(String autoCcLang) {
            this.autoCcLang = autoCcLang;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder embed(LiveEssentialsCreateEventForUserRequestEmbed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set folderUri
         * @param folderUri The URI of the event&#39;s folder. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder folderUri(String folderUri) {
            this.folderUri = folderUri;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder interactionToolsSettings(LiveEssentialsCreateEventForUserRequestInteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set lowLatency
         * @param lowLatency Whether the event has low-latency streaming enabled. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder lowLatency(Boolean lowLatency) {
            this.lowLatency = lowLatency;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set rtmpPreview
         * @param rtmpPreview Whether the event has RTMP preview enabled. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder rtmpPreview(Boolean rtmpPreview) {
            this.rtmpPreview = rtmpPreview;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder schedule(LiveEssentialsCreateEventForUserRequestSchedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder streamEmbed(LiveEssentialsCreateEventForUserRequestStreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder streamPrivacy(LiveEssentialsCreateEventForUserRequestStreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return CreateEventForUserRequestBuilder
         */
        public CreateEventForUserRequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for createEventForUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest = buildBodyParams();
            return createEventForUserCall(userId, liveEssentialsCreateEventForUserRequest, _callback);
        }

        private LiveEssentialsCreateEventForUserRequest buildBodyParams() {
            LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest = new LiveEssentialsCreateEventForUserRequest();
            liveEssentialsCreateEventForUserRequest.title(this.title);
            liveEssentialsCreateEventForUserRequest.allowShareLink(this.allowShareLink);
            liveEssentialsCreateEventForUserRequest.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsCreateEventForUserRequest.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLang != null)
            liveEssentialsCreateEventForUserRequest.autoCcLang(LiveEssentialsCreateEventForUserRequest.AutoCcLangEnum.fromValue(this.autoCcLang));
            liveEssentialsCreateEventForUserRequest.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsCreateEventForUserRequest.chatEnabled(this.chatEnabled);
            liveEssentialsCreateEventForUserRequest.contentRating(this.contentRating);
            liveEssentialsCreateEventForUserRequest.dvr(this.dvr);
            liveEssentialsCreateEventForUserRequest.embed(this.embed);
            liveEssentialsCreateEventForUserRequest.folderUri(this.folderUri);
            liveEssentialsCreateEventForUserRequest.interactionToolsSettings(this.interactionToolsSettings);
            liveEssentialsCreateEventForUserRequest.lowLatency(this.lowLatency);
            if (this.playlistSort != null)
            liveEssentialsCreateEventForUserRequest.playlistSort(LiveEssentialsCreateEventForUserRequest.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsCreateEventForUserRequest.rtmpPreview(this.rtmpPreview);
            liveEssentialsCreateEventForUserRequest.schedule(this.schedule);
            liveEssentialsCreateEventForUserRequest.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsCreateEventForUserRequest.streamDescription(this.streamDescription);
            liveEssentialsCreateEventForUserRequest.streamEmbed(this.streamEmbed);
            liveEssentialsCreateEventForUserRequest.streamPassword(this.streamPassword);
            liveEssentialsCreateEventForUserRequest.streamPrivacy(this.streamPrivacy);
            liveEssentialsCreateEventForUserRequest.streamTitle(this.streamTitle);
            liveEssentialsCreateEventForUserRequest.timeZone(this.timeZone);
            return liveEssentialsCreateEventForUserRequest;
        }

        /**
         * Execute createEventForUser request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = createEventForUserWithHttpInfo(userId, liveEssentialsCreateEventForUserRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createEventForUser request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest = buildBodyParams();
            return createEventForUserWithHttpInfo(userId, liveEssentialsCreateEventForUserRequest);
        }

        /**
         * Execute createEventForUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsCreateEventForUserRequest liveEssentialsCreateEventForUserRequest = buildBodyParams();
            return createEventForUserAsync(userId, liveEssentialsCreateEventForUserRequest, _callback);
        }
    }

    /**
     * Create a live event
     * This method creates a new event for the authenticated user.
     * @param userId The ID of the user. (required)
     * @param liveEssentialsCreateEventForUserRequest  (required)
     * @return CreateEventForUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
     </table>
     */
    public CreateEventForUserRequestBuilder createEventForUser(String title, double userId) throws IllegalArgumentException {
        if (title == null) throw new IllegalArgumentException("\"title\" is required but got null");
            

        
        return new CreateEventForUserRequestBuilder(title, userId);
    }
    private okhttp3.Call createLiveEventCall(LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsCreateLiveEventRequest;

        // create path and map variables
        String localVarPath = "/me/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createLiveEventValidateBeforeCall(LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEssentialsCreateLiveEventRequest' is set
        if (liveEssentialsCreateLiveEventRequest == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsCreateLiveEventRequest' when calling createLiveEvent(Async)");
        }

        return createLiveEventCall(liveEssentialsCreateLiveEventRequest, _callback);

    }


    private ApiResponse<LiveEventRecurring> createLiveEventWithHttpInfo(LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest) throws ApiException {
        okhttp3.Call localVarCall = createLiveEventValidateBeforeCall(liveEssentialsCreateLiveEventRequest, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createLiveEventAsync(LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = createLiveEventValidateBeforeCall(liveEssentialsCreateLiveEventRequest, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateLiveEventRequestBuilder {
        private final String title;
        private Boolean allowShareLink;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLang;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsCreateLiveEventRequestEmbed embed;
        private String folderUri;
        private LiveEssentialsCreateLiveEventRequestInteractionToolsSettings interactionToolsSettings;
        private Boolean lowLatency;
        private String playlistSort;
        private Boolean rtmpPreview;
        private LiveEssentialsCreateLiveEventRequestSchedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsCreateLiveEventRequestStreamEmbed streamEmbed;
        private String streamPassword;
        private LiveEssentialsCreateLiveEventRequestStreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private CreateLiveEventRequestBuilder(String title) {
            this.title = title;
        }

        /**
         * Set allowShareLink
         * @param allowShareLink Whether the share link is usable. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder allowShareLink(Boolean allowShareLink) {
            this.allowShareLink = allowShareLink;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords that improve the quality of the automated closed captions. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLang
         * @param autoCcLang The language in which the automated closed captions appear.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder autoCcLang(String autoCcLang) {
            this.autoCcLang = autoCcLang;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder embed(LiveEssentialsCreateLiveEventRequestEmbed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set folderUri
         * @param folderUri The URI of the event&#39;s folder. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder folderUri(String folderUri) {
            this.folderUri = folderUri;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder interactionToolsSettings(LiveEssentialsCreateLiveEventRequestInteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set lowLatency
         * @param lowLatency Whether the event has low-latency streaming enabled. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder lowLatency(Boolean lowLatency) {
            this.lowLatency = lowLatency;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set rtmpPreview
         * @param rtmpPreview Whether the event has RTMP preview enabled. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder rtmpPreview(Boolean rtmpPreview) {
            this.rtmpPreview = rtmpPreview;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder schedule(LiveEssentialsCreateLiveEventRequestSchedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder streamEmbed(LiveEssentialsCreateLiveEventRequestStreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder streamPrivacy(LiveEssentialsCreateLiveEventRequestStreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return CreateLiveEventRequestBuilder
         */
        public CreateLiveEventRequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for createLiveEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest = buildBodyParams();
            return createLiveEventCall(liveEssentialsCreateLiveEventRequest, _callback);
        }

        private LiveEssentialsCreateLiveEventRequest buildBodyParams() {
            LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest = new LiveEssentialsCreateLiveEventRequest();
            liveEssentialsCreateLiveEventRequest.title(this.title);
            liveEssentialsCreateLiveEventRequest.allowShareLink(this.allowShareLink);
            liveEssentialsCreateLiveEventRequest.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsCreateLiveEventRequest.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLang != null)
            liveEssentialsCreateLiveEventRequest.autoCcLang(LiveEssentialsCreateLiveEventRequest.AutoCcLangEnum.fromValue(this.autoCcLang));
            liveEssentialsCreateLiveEventRequest.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsCreateLiveEventRequest.chatEnabled(this.chatEnabled);
            liveEssentialsCreateLiveEventRequest.contentRating(this.contentRating);
            liveEssentialsCreateLiveEventRequest.dvr(this.dvr);
            liveEssentialsCreateLiveEventRequest.embed(this.embed);
            liveEssentialsCreateLiveEventRequest.folderUri(this.folderUri);
            liveEssentialsCreateLiveEventRequest.interactionToolsSettings(this.interactionToolsSettings);
            liveEssentialsCreateLiveEventRequest.lowLatency(this.lowLatency);
            if (this.playlistSort != null)
            liveEssentialsCreateLiveEventRequest.playlistSort(LiveEssentialsCreateLiveEventRequest.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsCreateLiveEventRequest.rtmpPreview(this.rtmpPreview);
            liveEssentialsCreateLiveEventRequest.schedule(this.schedule);
            liveEssentialsCreateLiveEventRequest.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsCreateLiveEventRequest.streamDescription(this.streamDescription);
            liveEssentialsCreateLiveEventRequest.streamEmbed(this.streamEmbed);
            liveEssentialsCreateLiveEventRequest.streamPassword(this.streamPassword);
            liveEssentialsCreateLiveEventRequest.streamPrivacy(this.streamPrivacy);
            liveEssentialsCreateLiveEventRequest.streamTitle(this.streamTitle);
            liveEssentialsCreateLiveEventRequest.timeZone(this.timeZone);
            return liveEssentialsCreateLiveEventRequest;
        }

        /**
         * Execute createLiveEvent request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = createLiveEventWithHttpInfo(liveEssentialsCreateLiveEventRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createLiveEvent request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest = buildBodyParams();
            return createLiveEventWithHttpInfo(liveEssentialsCreateLiveEventRequest);
        }

        /**
         * Execute createLiveEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsCreateLiveEventRequest liveEssentialsCreateLiveEventRequest = buildBodyParams();
            return createLiveEventAsync(liveEssentialsCreateLiveEventRequest, _callback);
        }
    }

    /**
     * Create a live event
     * This method creates a new event for the authenticated user.
     * @param liveEssentialsCreateLiveEventRequest  (required)
     * @return CreateLiveEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was created. </td><td>  -  </td></tr>
     </table>
     */
    public CreateLiveEventRequestBuilder createLiveEvent(String title) throws IllegalArgumentException {
        if (title == null) throw new IllegalArgumentException("\"title\" is required but got null");
            

        return new CreateLiveEventRequestBuilder(title);
    }
    private okhttp3.Call deleteMultipleEventsCall(LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsDeleteMultipleEventsRequest;

        // create path and map variables
        String localVarPath = "/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMultipleEventsValidateBeforeCall(LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEssentialsDeleteMultipleEventsRequest' is set
        if (liveEssentialsDeleteMultipleEventsRequest == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsDeleteMultipleEventsRequest' when calling deleteMultipleEvents(Async)");
        }

        return deleteMultipleEventsCall(liveEssentialsDeleteMultipleEventsRequest, _callback);

    }


    private ApiResponse<Void> deleteMultipleEventsWithHttpInfo(LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteMultipleEventsValidateBeforeCall(liveEssentialsDeleteMultipleEventsRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteMultipleEventsAsync(LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMultipleEventsValidateBeforeCall(liveEssentialsDeleteMultipleEventsRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteMultipleEventsRequestBuilder {
        private final String password;

        private DeleteMultipleEventsRequestBuilder(String password) {
            this.password = password;
        }

        /**
         * Build call for deleteMultipleEvents
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest = buildBodyParams();
            return deleteMultipleEventsCall(liveEssentialsDeleteMultipleEventsRequest, _callback);
        }

        private LiveEssentialsDeleteMultipleEventsRequest buildBodyParams() {
            LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest = new LiveEssentialsDeleteMultipleEventsRequest();
            liveEssentialsDeleteMultipleEventsRequest.password(this.password);
            return liveEssentialsDeleteMultipleEventsRequest;
        }

        /**
         * Execute deleteMultipleEvents request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest = buildBodyParams();
            deleteMultipleEventsWithHttpInfo(liveEssentialsDeleteMultipleEventsRequest);
        }

        /**
         * Execute deleteMultipleEvents request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest = buildBodyParams();
            return deleteMultipleEventsWithHttpInfo(liveEssentialsDeleteMultipleEventsRequest);
        }

        /**
         * Execute deleteMultipleEvents request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest liveEssentialsDeleteMultipleEventsRequest = buildBodyParams();
            return deleteMultipleEventsAsync(liveEssentialsDeleteMultipleEventsRequest, _callback);
        }
    }

    /**
     * Delete a list of live events
     * This method deletes multiple events belonging to the authenticated user.
     * @param liveEssentialsDeleteMultipleEventsRequest  (required)
     * @return DeleteMultipleEventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public DeleteMultipleEventsRequestBuilder deleteMultipleEvents(String password) throws IllegalArgumentException {
        if (password == null) throw new IllegalArgumentException("\"password\" is required but got null");
            

        return new DeleteMultipleEventsRequestBuilder(password);
    }
    private okhttp3.Call deleteMultipleEvents_0Call(LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsDeleteMultipleEventsRequest1;

        // create path and map variables
        String localVarPath = "/me/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMultipleEvents_0ValidateBeforeCall(LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEssentialsDeleteMultipleEventsRequest1' is set
        if (liveEssentialsDeleteMultipleEventsRequest1 == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsDeleteMultipleEventsRequest1' when calling deleteMultipleEvents_0(Async)");
        }

        return deleteMultipleEvents_0Call(liveEssentialsDeleteMultipleEventsRequest1, _callback);

    }


    private ApiResponse<Void> deleteMultipleEvents_0WithHttpInfo(LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1) throws ApiException {
        okhttp3.Call localVarCall = deleteMultipleEvents_0ValidateBeforeCall(liveEssentialsDeleteMultipleEventsRequest1, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteMultipleEvents_0Async(LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMultipleEvents_0ValidateBeforeCall(liveEssentialsDeleteMultipleEventsRequest1, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteMultipleEvents0RequestBuilder {
        private final String password;

        private DeleteMultipleEvents0RequestBuilder(String password) {
            this.password = password;
        }

        /**
         * Build call for deleteMultipleEvents_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1 = buildBodyParams();
            return deleteMultipleEvents_0Call(liveEssentialsDeleteMultipleEventsRequest1, _callback);
        }

        private LiveEssentialsDeleteMultipleEventsRequest1 buildBodyParams() {
            LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1 = new LiveEssentialsDeleteMultipleEventsRequest1();
            liveEssentialsDeleteMultipleEventsRequest1.password(this.password);
            return liveEssentialsDeleteMultipleEventsRequest1;
        }

        /**
         * Execute deleteMultipleEvents_0 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1 = buildBodyParams();
            deleteMultipleEvents_0WithHttpInfo(liveEssentialsDeleteMultipleEventsRequest1);
        }

        /**
         * Execute deleteMultipleEvents_0 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1 = buildBodyParams();
            return deleteMultipleEvents_0WithHttpInfo(liveEssentialsDeleteMultipleEventsRequest1);
        }

        /**
         * Execute deleteMultipleEvents_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest1 liveEssentialsDeleteMultipleEventsRequest1 = buildBodyParams();
            return deleteMultipleEvents_0Async(liveEssentialsDeleteMultipleEventsRequest1, _callback);
        }
    }

    /**
     * Delete a list of live events
     * This method deletes multiple events belonging to the authenticated user.
     * @param liveEssentialsDeleteMultipleEventsRequest1  (required)
     * @return DeleteMultipleEvents0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public DeleteMultipleEvents0RequestBuilder deleteMultipleEvents_0(String password) throws IllegalArgumentException {
        if (password == null) throw new IllegalArgumentException("\"password\" is required but got null");
            

        return new DeleteMultipleEvents0RequestBuilder(password);
    }
    private okhttp3.Call deleteMultipleEvents_1Call(Double userId, LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsDeleteMultipleEventsRequest2;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMultipleEvents_1ValidateBeforeCall(Double userId, LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling deleteMultipleEvents_1(Async)");
        }

        // verify the required parameter 'liveEssentialsDeleteMultipleEventsRequest2' is set
        if (liveEssentialsDeleteMultipleEventsRequest2 == null) {
            throw new ApiException("Missing the required parameter 'liveEssentialsDeleteMultipleEventsRequest2' when calling deleteMultipleEvents_1(Async)");
        }

        return deleteMultipleEvents_1Call(userId, liveEssentialsDeleteMultipleEventsRequest2, _callback);

    }


    private ApiResponse<Void> deleteMultipleEvents_1WithHttpInfo(Double userId, LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2) throws ApiException {
        okhttp3.Call localVarCall = deleteMultipleEvents_1ValidateBeforeCall(userId, liveEssentialsDeleteMultipleEventsRequest2, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteMultipleEvents_1Async(Double userId, LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMultipleEvents_1ValidateBeforeCall(userId, liveEssentialsDeleteMultipleEventsRequest2, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteMultipleEvents1RequestBuilder {
        private final String password;
        private final Double userId;

        private DeleteMultipleEvents1RequestBuilder(String password, double userId) {
            this.password = password;
            this.userId = userId;
        }

        /**
         * Build call for deleteMultipleEvents_1
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2 = buildBodyParams();
            return deleteMultipleEvents_1Call(userId, liveEssentialsDeleteMultipleEventsRequest2, _callback);
        }

        private LiveEssentialsDeleteMultipleEventsRequest2 buildBodyParams() {
            LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2 = new LiveEssentialsDeleteMultipleEventsRequest2();
            liveEssentialsDeleteMultipleEventsRequest2.password(this.password);
            return liveEssentialsDeleteMultipleEventsRequest2;
        }

        /**
         * Execute deleteMultipleEvents_1 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2 = buildBodyParams();
            deleteMultipleEvents_1WithHttpInfo(userId, liveEssentialsDeleteMultipleEventsRequest2);
        }

        /**
         * Execute deleteMultipleEvents_1 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2 = buildBodyParams();
            return deleteMultipleEvents_1WithHttpInfo(userId, liveEssentialsDeleteMultipleEventsRequest2);
        }

        /**
         * Execute deleteMultipleEvents_1 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            LiveEssentialsDeleteMultipleEventsRequest2 liveEssentialsDeleteMultipleEventsRequest2 = buildBodyParams();
            return deleteMultipleEvents_1Async(userId, liveEssentialsDeleteMultipleEventsRequest2, _callback);
        }
    }

    /**
     * Delete a list of live events
     * This method deletes multiple events belonging to the authenticated user.
     * @param userId The ID of the user. (required)
     * @param liveEssentialsDeleteMultipleEventsRequest2  (required)
     * @return DeleteMultipleEvents1RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public DeleteMultipleEvents1RequestBuilder deleteMultipleEvents_1(String password, double userId) throws IllegalArgumentException {
        if (password == null) throw new IllegalArgumentException("\"password\" is required but got null");
            

        
        return new DeleteMultipleEvents1RequestBuilder(password, userId);
    }
    private okhttp3.Call deleteSingleEventCall(Double liveEventId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSingleEventValidateBeforeCall(Double liveEventId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling deleteSingleEvent(Async)");
        }

        return deleteSingleEventCall(liveEventId, _callback);

    }


    private ApiResponse<Void> deleteSingleEventWithHttpInfo(Double liveEventId) throws ApiException {
        okhttp3.Call localVarCall = deleteSingleEventValidateBeforeCall(liveEventId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteSingleEventAsync(Double liveEventId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSingleEventValidateBeforeCall(liveEventId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteSingleEventRequestBuilder {
        private final Double liveEventId;

        private DeleteSingleEventRequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Build call for deleteSingleEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteSingleEventCall(liveEventId, _callback);
        }


        /**
         * Execute deleteSingleEvent request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteSingleEventWithHttpInfo(liveEventId);
        }

        /**
         * Execute deleteSingleEvent request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteSingleEventWithHttpInfo(liveEventId);
        }

        /**
         * Execute deleteSingleEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteSingleEventAsync(liveEventId, _callback);
        }
    }

    /**
     * Delete a specific live event
     * This method deletes a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return DeleteSingleEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteSingleEventRequestBuilder deleteSingleEvent(double liveEventId) throws IllegalArgumentException {
        
        return new DeleteSingleEventRequestBuilder(liveEventId);
    }
    private okhttp3.Call deleteSpecificEventCall(Double liveEventId, Double userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSpecificEventValidateBeforeCall(Double liveEventId, Double userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling deleteSpecificEvent(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling deleteSpecificEvent(Async)");
        }

        return deleteSpecificEventCall(liveEventId, userId, _callback);

    }


    private ApiResponse<Void> deleteSpecificEventWithHttpInfo(Double liveEventId, Double userId) throws ApiException {
        okhttp3.Call localVarCall = deleteSpecificEventValidateBeforeCall(liveEventId, userId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteSpecificEventAsync(Double liveEventId, Double userId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSpecificEventValidateBeforeCall(liveEventId, userId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteSpecificEventRequestBuilder {
        private final Double liveEventId;
        private final Double userId;

        private DeleteSpecificEventRequestBuilder(double liveEventId, double userId) {
            this.liveEventId = liveEventId;
            this.userId = userId;
        }

        /**
         * Build call for deleteSpecificEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteSpecificEventCall(liveEventId, userId, _callback);
        }


        /**
         * Execute deleteSpecificEvent request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteSpecificEventWithHttpInfo(liveEventId, userId);
        }

        /**
         * Execute deleteSpecificEvent request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteSpecificEventWithHttpInfo(liveEventId, userId);
        }

        /**
         * Execute deleteSpecificEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteSpecificEventAsync(liveEventId, userId, _callback);
        }
    }

    /**
     * Delete a specific live event
     * This method deletes a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @param userId The ID of the user. (required)
     * @return DeleteSpecificEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteSpecificEventRequestBuilder deleteSpecificEvent(double liveEventId, double userId) throws IllegalArgumentException {
        
        
        return new DeleteSpecificEventRequestBuilder(liveEventId, userId);
    }
    private okhttp3.Call deleteSpecificLiveEventCall(Double liveEventId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSpecificLiveEventValidateBeforeCall(Double liveEventId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling deleteSpecificLiveEvent(Async)");
        }

        return deleteSpecificLiveEventCall(liveEventId, _callback);

    }


    private ApiResponse<Void> deleteSpecificLiveEventWithHttpInfo(Double liveEventId) throws ApiException {
        okhttp3.Call localVarCall = deleteSpecificLiveEventValidateBeforeCall(liveEventId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteSpecificLiveEventAsync(Double liveEventId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSpecificLiveEventValidateBeforeCall(liveEventId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteSpecificLiveEventRequestBuilder {
        private final Double liveEventId;

        private DeleteSpecificLiveEventRequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Build call for deleteSpecificLiveEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteSpecificLiveEventCall(liveEventId, _callback);
        }


        /**
         * Execute deleteSpecificLiveEvent request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteSpecificLiveEventWithHttpInfo(liveEventId);
        }

        /**
         * Execute deleteSpecificLiveEvent request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteSpecificLiveEventWithHttpInfo(liveEventId);
        }

        /**
         * Execute deleteSpecificLiveEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteSpecificLiveEventAsync(liveEventId, _callback);
        }
    }

    /**
     * Delete a specific live event
     * This method deletes a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return DeleteSpecificLiveEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The event was deleted. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteSpecificLiveEventRequestBuilder deleteSpecificLiveEvent(double liveEventId) throws IllegalArgumentException {
        
        return new DeleteSpecificLiveEventRequestBuilder(liveEventId);
    }
    private okhttp3.Call getAllUserLiveEventsCall(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllUserLiveEventsValidateBeforeCall(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        return getAllUserLiveEventsCall(direction, filter, page, perPage, query, sort, type, _callback);

    }


    private ApiResponse<List<LiveEvent>> getAllUserLiveEventsWithHttpInfo(String direction, String filter, Double page, Double perPage, String query, String sort, String type) throws ApiException {
        okhttp3.Call localVarCall = getAllUserLiveEventsValidateBeforeCall(direction, filter, page, perPage, query, sort, type, null);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllUserLiveEventsAsync(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback<List<LiveEvent>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllUserLiveEventsValidateBeforeCall(direction, filter, page, perPage, query, sort, type, _callback);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllUserLiveEventsRequestBuilder {
        private String direction;
        private String filter;
        private Double page;
        private Double perPage;
        private String query;
        private String sort;
        private String type;

        private GetAllUserLiveEventsRequestBuilder() {
        }

        /**
         * Set direction
         * @param direction The sort direction of the results.  Option descriptions:  * &#x60;asc&#x60; - Sort the results in ascending order.  * &#x60;desc&#x60; - Sort the results in descending order.  (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder direction(String direction) {
            this.direction = direction;
            return this;
        }
        
        /**
         * Set filter
         * @param filter The attribute by which to filter the results.  Option descriptions:  * &#x60;not_in_folder&#x60; - Show only events that aren&#39;t in a folder.  * &#x60;not_in_showcase&#x60; - Show only events that aren&#39;t in a showcase.  * &#x60;not_in_webinar&#x60; - Show only events that aren&#39;t in a webinar.  (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set page
         * @param page The page number of the results to show. (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder page(Double page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set perPage
         * @param perPage The number of items to show on each page of results, up to a maximum of 100. (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder perPage(Double perPage) {
            this.perPage = perPage;
            return this;
        }
        
        /**
         * Set query
         * @param query The search query to use to filter the results. (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set sort
         * @param sort The way to sort the results.  Option descriptions:  * &#x60;alphabetical&#x60; - Sort the results alphabetically.  * &#x60;date&#x60; - Sort the results by creation date.  (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set type
         * @param type The type of event to return.  Option descriptions:  * &#x60;all&#x60; - Return all events.  * &#x60;one_time&#x60; - Return one-time events only.  * &#x60;recurring&#x60; - Return recurring events only.  (optional)
         * @return GetAllUserLiveEventsRequestBuilder
         */
        public GetAllUserLiveEventsRequestBuilder type(String type) {
            this.type = type;
            return this;
        }
        
        /**
         * Build call for getAllUserLiveEvents
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllUserLiveEventsCall(direction, filter, page, perPage, query, sort, type, _callback);
        }


        /**
         * Execute getAllUserLiveEvents request
         * @return List&lt;LiveEvent&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public List<LiveEvent> execute() throws ApiException {
            ApiResponse<List<LiveEvent>> localVarResp = getAllUserLiveEventsWithHttpInfo(direction, filter, page, perPage, query, sort, type);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllUserLiveEvents request with HTTP info returned
         * @return ApiResponse&lt;List&lt;LiveEvent&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<LiveEvent>> executeWithHttpInfo() throws ApiException {
            return getAllUserLiveEventsWithHttpInfo(direction, filter, page, perPage, query, sort, type);
        }

        /**
         * Execute getAllUserLiveEvents request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<LiveEvent>> _callback) throws ApiException {
            return getAllUserLiveEventsAsync(direction, filter, page, perPage, query, sort, type, _callback);
        }
    }

    /**
     * Get all the live events that belong to the user
     * The method returns every event belonging to the authenticated user.
     * @return GetAllUserLiveEventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetAllUserLiveEventsRequestBuilder getAllUserLiveEvents() throws IllegalArgumentException {
        return new GetAllUserLiveEventsRequestBuilder();
    }
    private okhttp3.Call getEventByIdCall(Double liveEventId, String password, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (password != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("password", password));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventByIdValidateBeforeCall(Double liveEventId, String password, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling getEventById(Async)");
        }

        return getEventByIdCall(liveEventId, password, _callback);

    }


    private ApiResponse<LiveEventRecurring> getEventByIdWithHttpInfo(Double liveEventId, String password) throws ApiException {
        okhttp3.Call localVarCall = getEventByIdValidateBeforeCall(liveEventId, password, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getEventByIdAsync(Double liveEventId, String password, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventByIdValidateBeforeCall(liveEventId, password, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetEventByIdRequestBuilder {
        private final Double liveEventId;
        private String password;

        private GetEventByIdRequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Set password
         * @param password The password of the event when the privacy is set to &#x60;password&#x60;. (optional)
         * @return GetEventByIdRequestBuilder
         */
        public GetEventByIdRequestBuilder password(String password) {
            this.password = password;
            return this;
        }
        
        /**
         * Build call for getEventById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getEventByIdCall(liveEventId, password, _callback);
        }


        /**
         * Execute getEventById request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            ApiResponse<LiveEventRecurring> localVarResp = getEventByIdWithHttpInfo(liveEventId, password);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getEventById request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            return getEventByIdWithHttpInfo(liveEventId, password);
        }

        /**
         * Execute getEventById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            return getEventByIdAsync(liveEventId, password, _callback);
        }
    }

    /**
     * Get a specific live event
     * This method returns a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return GetEventByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetEventByIdRequestBuilder getEventById(double liveEventId) throws IllegalArgumentException {
        
        return new GetEventByIdRequestBuilder(liveEventId);
    }
    private okhttp3.Call getEventById_0Call(Double liveEventId, Double userId, String password, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (password != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("password", password));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventById_0ValidateBeforeCall(Double liveEventId, Double userId, String password, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling getEventById_0(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getEventById_0(Async)");
        }

        return getEventById_0Call(liveEventId, userId, password, _callback);

    }


    private ApiResponse<LiveEventRecurring> getEventById_0WithHttpInfo(Double liveEventId, Double userId, String password) throws ApiException {
        okhttp3.Call localVarCall = getEventById_0ValidateBeforeCall(liveEventId, userId, password, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getEventById_0Async(Double liveEventId, Double userId, String password, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventById_0ValidateBeforeCall(liveEventId, userId, password, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetEventById0RequestBuilder {
        private final Double liveEventId;
        private final Double userId;
        private String password;

        private GetEventById0RequestBuilder(double liveEventId, double userId) {
            this.liveEventId = liveEventId;
            this.userId = userId;
        }

        /**
         * Set password
         * @param password The password of the event when the privacy is set to &#x60;password&#x60;. (optional)
         * @return GetEventById0RequestBuilder
         */
        public GetEventById0RequestBuilder password(String password) {
            this.password = password;
            return this;
        }
        
        /**
         * Build call for getEventById_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getEventById_0Call(liveEventId, userId, password, _callback);
        }


        /**
         * Execute getEventById_0 request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            ApiResponse<LiveEventRecurring> localVarResp = getEventById_0WithHttpInfo(liveEventId, userId, password);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getEventById_0 request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            return getEventById_0WithHttpInfo(liveEventId, userId, password);
        }

        /**
         * Execute getEventById_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            return getEventById_0Async(liveEventId, userId, password, _callback);
        }
    }

    /**
     * Get a specific live event
     * This method returns a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @param userId The ID of the user. (required)
     * @return GetEventById0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetEventById0RequestBuilder getEventById_0(double liveEventId, double userId) throws IllegalArgumentException {
        
        
        return new GetEventById0RequestBuilder(liveEventId, userId);
    }
    private okhttp3.Call getSpecificLiveEventCall(Double liveEventId, String password, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (password != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("password", password));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSpecificLiveEventValidateBeforeCall(Double liveEventId, String password, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling getSpecificLiveEvent(Async)");
        }

        return getSpecificLiveEventCall(liveEventId, password, _callback);

    }


    private ApiResponse<LiveEventRecurring> getSpecificLiveEventWithHttpInfo(Double liveEventId, String password) throws ApiException {
        okhttp3.Call localVarCall = getSpecificLiveEventValidateBeforeCall(liveEventId, password, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSpecificLiveEventAsync(Double liveEventId, String password, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSpecificLiveEventValidateBeforeCall(liveEventId, password, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSpecificLiveEventRequestBuilder {
        private final Double liveEventId;
        private String password;

        private GetSpecificLiveEventRequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Set password
         * @param password The password of the event when the privacy is set to &#x60;password&#x60;. (optional)
         * @return GetSpecificLiveEventRequestBuilder
         */
        public GetSpecificLiveEventRequestBuilder password(String password) {
            this.password = password;
            return this;
        }
        
        /**
         * Build call for getSpecificLiveEvent
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSpecificLiveEventCall(liveEventId, password, _callback);
        }


        /**
         * Execute getSpecificLiveEvent request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            ApiResponse<LiveEventRecurring> localVarResp = getSpecificLiveEventWithHttpInfo(liveEventId, password);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSpecificLiveEvent request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            return getSpecificLiveEventWithHttpInfo(liveEventId, password);
        }

        /**
         * Execute getSpecificLiveEvent request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            return getSpecificLiveEventAsync(liveEventId, password, _callback);
        }
    }

    /**
     * Get a specific live event
     * This method returns a single event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return GetSpecificLiveEventRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetSpecificLiveEventRequestBuilder getSpecificLiveEvent(double liveEventId) throws IllegalArgumentException {
        
        return new GetSpecificLiveEventRequestBuilder(liveEventId);
    }
    private okhttp3.Call getUserLiveEventsCall(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/live_events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserLiveEventsValidateBeforeCall(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        return getUserLiveEventsCall(direction, filter, page, perPage, query, sort, type, _callback);

    }


    private ApiResponse<List<LiveEvent>> getUserLiveEventsWithHttpInfo(String direction, String filter, Double page, Double perPage, String query, String sort, String type) throws ApiException {
        okhttp3.Call localVarCall = getUserLiveEventsValidateBeforeCall(direction, filter, page, perPage, query, sort, type, null);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserLiveEventsAsync(String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback<List<LiveEvent>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserLiveEventsValidateBeforeCall(direction, filter, page, perPage, query, sort, type, _callback);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserLiveEventsRequestBuilder {
        private String direction;
        private String filter;
        private Double page;
        private Double perPage;
        private String query;
        private String sort;
        private String type;

        private GetUserLiveEventsRequestBuilder() {
        }

        /**
         * Set direction
         * @param direction The sort direction of the results.  Option descriptions:  * &#x60;asc&#x60; - Sort the results in ascending order.  * &#x60;desc&#x60; - Sort the results in descending order.  (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder direction(String direction) {
            this.direction = direction;
            return this;
        }
        
        /**
         * Set filter
         * @param filter The attribute by which to filter the results.  Option descriptions:  * &#x60;not_in_folder&#x60; - Show only events that aren&#39;t in a folder.  * &#x60;not_in_showcase&#x60; - Show only events that aren&#39;t in a showcase.  * &#x60;not_in_webinar&#x60; - Show only events that aren&#39;t in a webinar.  (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set page
         * @param page The page number of the results to show. (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder page(Double page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set perPage
         * @param perPage The number of items to show on each page of results, up to a maximum of 100. (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder perPage(Double perPage) {
            this.perPage = perPage;
            return this;
        }
        
        /**
         * Set query
         * @param query The search query to use to filter the results. (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set sort
         * @param sort The way to sort the results.  Option descriptions:  * &#x60;alphabetical&#x60; - Sort the results alphabetically.  * &#x60;date&#x60; - Sort the results by creation date.  (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set type
         * @param type The type of event to return.  Option descriptions:  * &#x60;all&#x60; - Return all events.  * &#x60;one_time&#x60; - Return one-time events only.  * &#x60;recurring&#x60; - Return recurring events only.  (optional)
         * @return GetUserLiveEventsRequestBuilder
         */
        public GetUserLiveEventsRequestBuilder type(String type) {
            this.type = type;
            return this;
        }
        
        /**
         * Build call for getUserLiveEvents
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserLiveEventsCall(direction, filter, page, perPage, query, sort, type, _callback);
        }


        /**
         * Execute getUserLiveEvents request
         * @return List&lt;LiveEvent&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public List<LiveEvent> execute() throws ApiException {
            ApiResponse<List<LiveEvent>> localVarResp = getUserLiveEventsWithHttpInfo(direction, filter, page, perPage, query, sort, type);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserLiveEvents request with HTTP info returned
         * @return ApiResponse&lt;List&lt;LiveEvent&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<LiveEvent>> executeWithHttpInfo() throws ApiException {
            return getUserLiveEventsWithHttpInfo(direction, filter, page, perPage, query, sort, type);
        }

        /**
         * Execute getUserLiveEvents request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<LiveEvent>> _callback) throws ApiException {
            return getUserLiveEventsAsync(direction, filter, page, perPage, query, sort, type, _callback);
        }
    }

    /**
     * Get all the live events that belong to the user
     * The method returns every event belonging to the authenticated user.
     * @return GetUserLiveEventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetUserLiveEventsRequestBuilder getUserLiveEvents() throws IllegalArgumentException {
        return new GetUserLiveEventsRequestBuilder();
    }
    private okhttp3.Call getUserLiveEvents_0Call(Double userId, String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserLiveEvents_0ValidateBeforeCall(Double userId, String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUserLiveEvents_0(Async)");
        }

        return getUserLiveEvents_0Call(userId, direction, filter, page, perPage, query, sort, type, _callback);

    }


    private ApiResponse<List<LiveEvent>> getUserLiveEvents_0WithHttpInfo(Double userId, String direction, String filter, Double page, Double perPage, String query, String sort, String type) throws ApiException {
        okhttp3.Call localVarCall = getUserLiveEvents_0ValidateBeforeCall(userId, direction, filter, page, perPage, query, sort, type, null);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserLiveEvents_0Async(Double userId, String direction, String filter, Double page, Double perPage, String query, String sort, String type, final ApiCallback<List<LiveEvent>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserLiveEvents_0ValidateBeforeCall(userId, direction, filter, page, perPage, query, sort, type, _callback);
        Type localVarReturnType = new TypeToken<List<LiveEvent>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserLiveEvents0RequestBuilder {
        private final Double userId;
        private String direction;
        private String filter;
        private Double page;
        private Double perPage;
        private String query;
        private String sort;
        private String type;

        private GetUserLiveEvents0RequestBuilder(double userId) {
            this.userId = userId;
        }

        /**
         * Set direction
         * @param direction The sort direction of the results.  Option descriptions:  * &#x60;asc&#x60; - Sort the results in ascending order.  * &#x60;desc&#x60; - Sort the results in descending order.  (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder direction(String direction) {
            this.direction = direction;
            return this;
        }
        
        /**
         * Set filter
         * @param filter The attribute by which to filter the results.  Option descriptions:  * &#x60;not_in_folder&#x60; - Show only events that aren&#39;t in a folder.  * &#x60;not_in_showcase&#x60; - Show only events that aren&#39;t in a showcase.  * &#x60;not_in_webinar&#x60; - Show only events that aren&#39;t in a webinar.  (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set page
         * @param page The page number of the results to show. (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder page(Double page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set perPage
         * @param perPage The number of items to show on each page of results, up to a maximum of 100. (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder perPage(Double perPage) {
            this.perPage = perPage;
            return this;
        }
        
        /**
         * Set query
         * @param query The search query to use to filter the results. (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set sort
         * @param sort The way to sort the results.  Option descriptions:  * &#x60;alphabetical&#x60; - Sort the results alphabetically.  * &#x60;date&#x60; - Sort the results by creation date.  (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set type
         * @param type The type of event to return.  Option descriptions:  * &#x60;all&#x60; - Return all events.  * &#x60;one_time&#x60; - Return one-time events only.  * &#x60;recurring&#x60; - Return recurring events only.  (optional)
         * @return GetUserLiveEvents0RequestBuilder
         */
        public GetUserLiveEvents0RequestBuilder type(String type) {
            this.type = type;
            return this;
        }
        
        /**
         * Build call for getUserLiveEvents_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserLiveEvents_0Call(userId, direction, filter, page, perPage, query, sort, type, _callback);
        }


        /**
         * Execute getUserLiveEvents_0 request
         * @return List&lt;LiveEvent&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public List<LiveEvent> execute() throws ApiException {
            ApiResponse<List<LiveEvent>> localVarResp = getUserLiveEvents_0WithHttpInfo(userId, direction, filter, page, perPage, query, sort, type);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserLiveEvents_0 request with HTTP info returned
         * @return ApiResponse&lt;List&lt;LiveEvent&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<LiveEvent>> executeWithHttpInfo() throws ApiException {
            return getUserLiveEvents_0WithHttpInfo(userId, direction, filter, page, perPage, query, sort, type);
        }

        /**
         * Execute getUserLiveEvents_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<LiveEvent>> _callback) throws ApiException {
            return getUserLiveEvents_0Async(userId, direction, filter, page, perPage, query, sort, type, _callback);
        }
    }

    /**
     * Get all the live events that belong to the user
     * The method returns every event belonging to the authenticated user.
     * @param userId The ID of the user. (required)
     * @return GetUserLiveEvents0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The events were returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetUserLiveEvents0RequestBuilder getUserLiveEvents_0(double userId) throws IllegalArgumentException {
        
        return new GetUserLiveEvents0RequestBuilder(userId);
    }
    private okhttp3.Call updateEventBelongingToAuthenticatedUserCall(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest;

        // create path and map variables
        String localVarPath = "/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEventBelongingToAuthenticatedUserValidateBeforeCall(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling updateEventBelongingToAuthenticatedUser(Async)");
        }

        return updateEventBelongingToAuthenticatedUserCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, _callback);

    }


    private ApiResponse<LiveEventRecurring> updateEventBelongingToAuthenticatedUserWithHttpInfo(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest) throws ApiException {
        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUserValidateBeforeCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateEventBelongingToAuthenticatedUserAsync(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUserValidateBeforeCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateEventBelongingToAuthenticatedUserRequestBuilder {
        private final Double liveEventId;
        private String title;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLanguage;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestEmbed embed;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestInteractionToolsSettings interactionToolsSettings;
        private String playlistSort;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestSchedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamEmbed streamEmbed;
        private String streamMode;
        private String streamPassword;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private UpdateEventBelongingToAuthenticatedUserRequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Set title
         * @param title The title of the event. If **automatically_title_stream** is &#x60;true&#x60;, this value is the base title for videos created by streaming to this event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder title(String title) {
            this.title = title;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords for enhancing the speech detection of automated closed captions. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLanguage
         * @param autoCcLanguage The language of the automated closed captions.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder autoCcLanguage(String autoCcLanguage) {
            this.autoCcLanguage = autoCcLanguage;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder embed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestEmbed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder interactionToolsSettings(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestInteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder schedule(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestSchedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamEmbed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamMode
         * @param streamMode The stream mode of the event.  Option descriptions:  * &#x60;live&#x60; - The stream is live playback.  * &#x60;record&#x60; - The stream is in record mode.  * &#x60;simulive&#x60; - The stream is scheduled media playback.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamMode(String streamMode) {
            this.streamMode = streamMode;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamPrivacy(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequestStreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUserRequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for updateEventBelongingToAuthenticatedUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest = buildBodyParams();
            return updateEventBelongingToAuthenticatedUserCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, _callback);
        }

        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest buildBodyParams() {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest = new LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest();
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.title(this.title);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLanguage != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.autoCcLanguage(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.AutoCcLanguageEnum.fromValue(this.autoCcLanguage));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.chatEnabled(this.chatEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.contentRating(this.contentRating);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.dvr(this.dvr);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.embed(this.embed);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.interactionToolsSettings(this.interactionToolsSettings);
            if (this.playlistSort != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.playlistSort(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.schedule(this.schedule);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamDescription(this.streamDescription);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamEmbed(this.streamEmbed);
            if (this.streamMode != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamMode(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.StreamModeEnum.fromValue(this.streamMode));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamPassword(this.streamPassword);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamPrivacy(this.streamPrivacy);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.streamTitle(this.streamTitle);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest.timeZone(this.timeZone);
            return liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest;
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = updateEventBelongingToAuthenticatedUserWithHttpInfo(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest = buildBodyParams();
            return updateEventBelongingToAuthenticatedUserWithHttpInfo(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest);
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest = buildBodyParams();
            return updateEventBelongingToAuthenticatedUserAsync(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest, _callback);
        }
    }

    /**
     * Update a live event
     * This method updates an event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return UpdateEventBelongingToAuthenticatedUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateEventBelongingToAuthenticatedUserRequestBuilder updateEventBelongingToAuthenticatedUser(double liveEventId) throws IllegalArgumentException {
        
        return new UpdateEventBelongingToAuthenticatedUserRequestBuilder(liveEventId);
    }
    private okhttp3.Call updateEventBelongingToAuthenticatedUser_0Call(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1;

        // create path and map variables
        String localVarPath = "/me/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEventBelongingToAuthenticatedUser_0ValidateBeforeCall(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling updateEventBelongingToAuthenticatedUser_0(Async)");
        }

        return updateEventBelongingToAuthenticatedUser_0Call(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, _callback);

    }


    private ApiResponse<LiveEventRecurring> updateEventBelongingToAuthenticatedUser_0WithHttpInfo(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1) throws ApiException {
        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUser_0ValidateBeforeCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateEventBelongingToAuthenticatedUser_0Async(Double liveEventId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUser_0ValidateBeforeCall(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateEventBelongingToAuthenticatedUser0RequestBuilder {
        private final Double liveEventId;
        private String title;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLanguage;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Embed embed;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1InteractionToolsSettings interactionToolsSettings;
        private String playlistSort;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Schedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamEmbed streamEmbed;
        private String streamMode;
        private String streamPassword;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private UpdateEventBelongingToAuthenticatedUser0RequestBuilder(double liveEventId) {
            this.liveEventId = liveEventId;
        }

        /**
         * Set title
         * @param title The title of the event. If **automatically_title_stream** is &#x60;true&#x60;, this value is the base title for videos created by streaming to this event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder title(String title) {
            this.title = title;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords for enhancing the speech detection of automated closed captions. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLanguage
         * @param autoCcLanguage The language of the automated closed captions.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder autoCcLanguage(String autoCcLanguage) {
            this.autoCcLanguage = autoCcLanguage;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder embed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Embed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder interactionToolsSettings(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1InteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder schedule(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1Schedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamEmbed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamMode
         * @param streamMode The stream mode of the event.  Option descriptions:  * &#x60;live&#x60; - The stream is live playback.  * &#x60;record&#x60; - The stream is in record mode.  * &#x60;simulive&#x60; - The stream is scheduled media playback.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamMode(String streamMode) {
            this.streamMode = streamMode;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamPrivacy(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1StreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser0RequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for updateEventBelongingToAuthenticatedUser_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_0Call(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, _callback);
        }

        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 buildBodyParams() {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 = new LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1();
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.title(this.title);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLanguage != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.autoCcLanguage(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.AutoCcLanguageEnum.fromValue(this.autoCcLanguage));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.chatEnabled(this.chatEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.contentRating(this.contentRating);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.dvr(this.dvr);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.embed(this.embed);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.interactionToolsSettings(this.interactionToolsSettings);
            if (this.playlistSort != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.playlistSort(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.schedule(this.schedule);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamDescription(this.streamDescription);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamEmbed(this.streamEmbed);
            if (this.streamMode != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamMode(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.StreamModeEnum.fromValue(this.streamMode));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamPassword(this.streamPassword);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamPrivacy(this.streamPrivacy);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.streamTitle(this.streamTitle);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1.timeZone(this.timeZone);
            return liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1;
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_0 request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = updateEventBelongingToAuthenticatedUser_0WithHttpInfo(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_0 request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_0WithHttpInfo(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1);
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_0Async(liveEventId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest1, _callback);
        }
    }

    /**
     * Update a live event
     * This method updates an event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @return UpdateEventBelongingToAuthenticatedUser0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateEventBelongingToAuthenticatedUser0RequestBuilder updateEventBelongingToAuthenticatedUser_0(double liveEventId) throws IllegalArgumentException {
        
        return new UpdateEventBelongingToAuthenticatedUser0RequestBuilder(liveEventId);
    }
    private okhttp3.Call updateEventBelongingToAuthenticatedUser_1Call(Double liveEventId, Double userId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2;

        // create path and map variables
        String localVarPath = "/users/{user_id}/live_events/{live_event_id}"
            .replace("{" + "live_event_id" + "}", localVarApiClient.escapeString(liveEventId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.vimeo.live.event.recurring+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2", "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEventBelongingToAuthenticatedUser_1ValidateBeforeCall(Double liveEventId, Double userId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'liveEventId' is set
        if (liveEventId == null) {
            throw new ApiException("Missing the required parameter 'liveEventId' when calling updateEventBelongingToAuthenticatedUser_1(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling updateEventBelongingToAuthenticatedUser_1(Async)");
        }

        return updateEventBelongingToAuthenticatedUser_1Call(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, _callback);

    }


    private ApiResponse<LiveEventRecurring> updateEventBelongingToAuthenticatedUser_1WithHttpInfo(Double liveEventId, Double userId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2) throws ApiException {
        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUser_1ValidateBeforeCall(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, null);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateEventBelongingToAuthenticatedUser_1Async(Double liveEventId, Double userId, LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, final ApiCallback<LiveEventRecurring> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEventBelongingToAuthenticatedUser_1ValidateBeforeCall(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, _callback);
        Type localVarReturnType = new TypeToken<LiveEventRecurring>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateEventBelongingToAuthenticatedUser1RequestBuilder {
        private final Double liveEventId;
        private final Double userId;
        private String title;
        private Boolean autoCcEnabled;
        private String autoCcKeywords;
        private String autoCcLanguage;
        private Boolean automaticallyTitleStream;
        private Boolean chatEnabled;
        private List<String> contentRating;
        private Boolean dvr;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Embed embed;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2InteractionToolsSettings interactionToolsSettings;
        private String playlistSort;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Schedule schedule;
        private Boolean scheduledPlayback;
        private String streamDescription;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamEmbed streamEmbed;
        private String streamMode;
        private String streamPassword;
        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamPrivacy streamPrivacy;
        private String streamTitle;
        private String timeZone;

        private UpdateEventBelongingToAuthenticatedUser1RequestBuilder(double liveEventId, double userId) {
            this.liveEventId = liveEventId;
            this.userId = userId;
        }

        /**
         * Set title
         * @param title The title of the event. If **automatically_title_stream** is &#x60;true&#x60;, this value is the base title for videos created by streaming to this event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder title(String title) {
            this.title = title;
            return this;
        }
        
        /**
         * Set autoCcEnabled
         * @param autoCcEnabled Whether automated closed captions are enabled for the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder autoCcEnabled(Boolean autoCcEnabled) {
            this.autoCcEnabled = autoCcEnabled;
            return this;
        }
        
        /**
         * Set autoCcKeywords
         * @param autoCcKeywords A comma-separated list of keywords for enhancing the speech detection of automated closed captions. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder autoCcKeywords(String autoCcKeywords) {
            this.autoCcKeywords = autoCcKeywords;
            return this;
        }
        
        /**
         * Set autoCcLanguage
         * @param autoCcLanguage The language of the automated closed captions.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder autoCcLanguage(String autoCcLanguage) {
            this.autoCcLanguage = autoCcLanguage;
            return this;
        }
        
        /**
         * Set automaticallyTitleStream
         * @param automaticallyTitleStream Whether the title for the next video in the event is generated based on the time of the stream and the **title** field of the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder automaticallyTitleStream(Boolean automaticallyTitleStream) {
            this.automaticallyTitleStream = automaticallyTitleStream;
            return this;
        }
        
        /**
         * Set chatEnabled
         * @param chatEnabled Whether to display the live chat client on the Vimeo event page. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder chatEnabled(Boolean chatEnabled) {
            this.chatEnabled = chatEnabled;
            return this;
        }
        
        /**
         * Set contentRating
         * @param contentRating A list of values describing the content in this event. To return the list of all possible content rating values, use the [&#x60;/contentratings&#x60;](https://developer.vimeo.com/api/reference/videos#get_content_ratings) endpoint. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder contentRating(List<String> contentRating) {
            this.contentRating = contentRating;
            return this;
        }
        
        /**
         * Set dvr
         * @param dvr Whether the DVR feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder dvr(Boolean dvr) {
            this.dvr = dvr;
            return this;
        }
        
        /**
         * Set embed
         * @param embed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder embed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Embed embed) {
            this.embed = embed;
            return this;
        }
        
        /**
         * Set interactionToolsSettings
         * @param interactionToolsSettings  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder interactionToolsSettings(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2InteractionToolsSettings interactionToolsSettings) {
            this.interactionToolsSettings = interactionToolsSettings;
            return this;
        }
        
        /**
         * Set playlistSort
         * @param playlistSort The order in which the videos of the event appear within the event&#39;s playlist.  Option descriptions:  * &#x60;added_first&#x60; - The most recently added videos appear first.  * &#x60;added_last&#x60; - The most recently added videos appear last.  * &#x60;alphabetical&#x60; - The videos appear in alphabetical order.  * &#x60;arranged&#x60; - The videos appear in the order in which the user has arranged them.  * &#x60;comments&#x60; - The videos appear in order of number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear in order of number of likes.  * &#x60;newest&#x60; - The newest videos appear first.  * &#x60;oldest&#x60; - The oldest videos appear first.  * &#x60;plays&#x60; - The videos appear in order of number of plays.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder playlistSort(String playlistSort) {
            this.playlistSort = playlistSort;
            return this;
        }
        
        /**
         * Set schedule
         * @param schedule  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder schedule(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2Schedule schedule) {
            this.schedule = schedule;
            return this;
        }
        
        /**
         * Set scheduledPlayback
         * @param scheduledPlayback Whether the scheduled playback feature is enabled. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder scheduledPlayback(Boolean scheduledPlayback) {
            this.scheduledPlayback = scheduledPlayback;
            return this;
        }
        
        /**
         * Set streamDescription
         * @param streamDescription The description of the next video to be streamed to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamDescription(String streamDescription) {
            this.streamDescription = streamDescription;
            return this;
        }
        
        /**
         * Set streamEmbed
         * @param streamEmbed  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamEmbed(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamEmbed streamEmbed) {
            this.streamEmbed = streamEmbed;
            return this;
        }
        
        /**
         * Set streamMode
         * @param streamMode The stream mode of the event.  Option descriptions:  * &#x60;live&#x60; - The stream is live playback.  * &#x60;record&#x60; - The stream is in record mode.  * &#x60;simulive&#x60; - The stream is scheduled media playback.  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamMode(String streamMode) {
            this.streamMode = streamMode;
            return this;
        }
        
        /**
         * Set streamPassword
         * @param streamPassword The password when **stream_privacy.view** is &#x60;password&#x60;. Anyone with the password can view the videos generated by streaming to the event. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamPassword(String streamPassword) {
            this.streamPassword = streamPassword;
            return this;
        }
        
        /**
         * Set streamPrivacy
         * @param streamPrivacy  (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamPrivacy(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2StreamPrivacy streamPrivacy) {
            this.streamPrivacy = streamPrivacy;
            return this;
        }
        
        /**
         * Set streamTitle
         * @param streamTitle The title of the next video to be streamed to the event. This parameter is required when **automatically_title_stream** is &#x60;false&#x60;. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder streamTitle(String streamTitle) {
            this.streamTitle = streamTitle;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone used in resolving the timestamps that are included in automatically generated video titles. (optional)
         * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
         */
        public UpdateEventBelongingToAuthenticatedUser1RequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for updateEventBelongingToAuthenticatedUser_1
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_1Call(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, _callback);
        }

        private LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 buildBodyParams() {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 = new LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2();
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.title(this.title);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.autoCcEnabled(this.autoCcEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.autoCcKeywords(this.autoCcKeywords);
            if (this.autoCcLanguage != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.autoCcLanguage(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.AutoCcLanguageEnum.fromValue(this.autoCcLanguage));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.automaticallyTitleStream(this.automaticallyTitleStream);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.chatEnabled(this.chatEnabled);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.contentRating(this.contentRating);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.dvr(this.dvr);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.embed(this.embed);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.interactionToolsSettings(this.interactionToolsSettings);
            if (this.playlistSort != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.playlistSort(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.PlaylistSortEnum.fromValue(this.playlistSort));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.schedule(this.schedule);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.scheduledPlayback(this.scheduledPlayback);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamDescription(this.streamDescription);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamEmbed(this.streamEmbed);
            if (this.streamMode != null)
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamMode(LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.StreamModeEnum.fromValue(this.streamMode));
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamPassword(this.streamPassword);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamPrivacy(this.streamPrivacy);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.streamTitle(this.streamTitle);
            liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2.timeZone(this.timeZone);
            return liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2;
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_1 request
         * @return LiveEventRecurring
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public LiveEventRecurring execute() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 = buildBodyParams();
            ApiResponse<LiveEventRecurring> localVarResp = updateEventBelongingToAuthenticatedUser_1WithHttpInfo(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_1 request with HTTP info returned
         * @return ApiResponse&lt;LiveEventRecurring&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<LiveEventRecurring> executeWithHttpInfo() throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_1WithHttpInfo(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2);
        }

        /**
         * Execute updateEventBelongingToAuthenticatedUser_1 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<LiveEventRecurring> _callback) throws ApiException {
            LiveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2 = buildBodyParams();
            return updateEventBelongingToAuthenticatedUser_1Async(liveEventId, userId, liveEssentialsUpdateEventBelongingToAuthenticatedUserRequest2, _callback);
        }
    }

    /**
     * Update a live event
     * This method updates an event belonging to the authenticated user.
     * @param liveEventId The ID of the event. (required)
     * @param userId The ID of the user. (required)
     * @return UpdateEventBelongingToAuthenticatedUser1RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The event was updated. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateEventBelongingToAuthenticatedUser1RequestBuilder updateEventBelongingToAuthenticatedUser_1(double liveEventId, double userId) throws IllegalArgumentException {
        
        
        return new UpdateEventBelongingToAuthenticatedUser1RequestBuilder(liveEventId, userId);
    }
}
