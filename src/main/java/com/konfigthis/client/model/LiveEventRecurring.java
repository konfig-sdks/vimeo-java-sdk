/*
 * Vimeo API
 * Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.
 *
 * The version of the OpenAPI document: 3.4
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.LiveEventInteractionToolsSettingsInner;
import com.konfigthis.client.model.LiveEventRecurringEmailQuota;
import com.konfigthis.client.model.LiveEventRecurringEmbed;
import com.konfigthis.client.model.LiveEventRecurringMetadata;
import com.konfigthis.client.model.LiveEventRecurringStreamPrivacy;
import com.konfigthis.client.model.LiveEventSchedule;
import com.konfigthis.client.model.Picture;
import com.konfigthis.client.model.Project;
import com.konfigthis.client.model.User;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * LiveEventRecurring
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class LiveEventRecurring {
  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_ALBUM = "album";
  @SerializedName(SERIALIZED_NAME_ALBUM)
  private List<String> album = new ArrayList<>();

  public static final String SERIALIZED_NAME_ALLOW_SHARE_LINK = "allow_share_link";
  @SerializedName(SERIALIZED_NAME_ALLOW_SHARE_LINK)
  private Boolean allowShareLink;

  public static final String SERIALIZED_NAME_ALLOWED_PRIVACIES = "allowed_privacies";
  @SerializedName(SERIALIZED_NAME_ALLOWED_PRIVACIES)
  private List<String> allowedPrivacies = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTO_CC_ENABLED = "auto_cc_enabled";
  @SerializedName(SERIALIZED_NAME_AUTO_CC_ENABLED)
  private Boolean autoCcEnabled;

  public static final String SERIALIZED_NAME_AUTO_CC_KEYWORDS = "auto_cc_keywords";
  @SerializedName(SERIALIZED_NAME_AUTO_CC_KEYWORDS)
  private String autoCcKeywords;

  /**
   * The language of the automated closed captions.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese. 
   */
  @JsonAdapter(AutoCcLanguageEnum.Adapter.class)
 public enum AutoCcLanguageEnum {
    DE_DE("de-DE"),
    
    EN_US("en-US"),
    
    ES_ES("es-ES"),
    
    FR_FR("fr-FR"),
    
    PT_BR("pt-BR");

    private String value;

    AutoCcLanguageEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AutoCcLanguageEnum fromValue(String value) {
      for (AutoCcLanguageEnum b : AutoCcLanguageEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<AutoCcLanguageEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AutoCcLanguageEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AutoCcLanguageEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AutoCcLanguageEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_AUTO_CC_LANGUAGE = "auto_cc_language";
  @SerializedName(SERIALIZED_NAME_AUTO_CC_LANGUAGE)
  private AutoCcLanguageEnum autoCcLanguage;

  public static final String SERIALIZED_NAME_AUTO_CC_REMAINING = "auto_cc_remaining";
  @SerializedName(SERIALIZED_NAME_AUTO_CC_REMAINING)
  private Double autoCcRemaining;

  public static final String SERIALIZED_NAME_AUTOMATICALLY_TITLE_STREAM = "automatically_title_stream";
  @SerializedName(SERIALIZED_NAME_AUTOMATICALLY_TITLE_STREAM)
  private Boolean automaticallyTitleStream;

  public static final String SERIALIZED_NAME_CHAT_ENABLED = "chat_enabled";
  @SerializedName(SERIALIZED_NAME_CHAT_ENABLED)
  private Boolean chatEnabled;

  public static final String SERIALIZED_NAME_COMPLETED_ON = "completed_on";
  @SerializedName(SERIALIZED_NAME_COMPLETED_ON)
  private String completedOn;

  /**
   * Gets or Sets contentRating
   */
  @JsonAdapter(String.Adapter.class)
 public enum String {

    private String value;

    String(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static String fromValue(String value) {
      for (String b : String.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<String> {
      @Override
      public void write(final JsonWriter jsonWriter, final String enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public String read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return String.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CONTENT_RATING = "content_rating";
  @SerializedName(SERIALIZED_NAME_CONTENT_RATING)
  private ContentRatingEnum contentRating = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATED_TIME = "created_time";
  @SerializedName(SERIALIZED_NAME_CREATED_TIME)
  private String createdTime;

  public static final String SERIALIZED_NAME_DVR = "dvr";
  @SerializedName(SERIALIZED_NAME_DVR)
  private Boolean dvr;

  public static final String SERIALIZED_NAME_EMAIL_QUOTA = "email_quota";
  @SerializedName(SERIALIZED_NAME_EMAIL_QUOTA)
  private LiveEventRecurringEmailQuota emailQuota;

  public static final String SERIALIZED_NAME_EMBED = "embed";
  @SerializedName(SERIALIZED_NAME_EMBED)
  private LiveEventRecurringEmbed embed;

  public static final String SERIALIZED_NAME_FROM_SHOWCASE = "from_showcase";
  @SerializedName(SERIALIZED_NAME_FROM_SHOWCASE)
  private Boolean fromShowcase;

  public static final String SERIALIZED_NAME_FROM_WEBINAR = "from_webinar";
  @SerializedName(SERIALIZED_NAME_FROM_WEBINAR)
  private Boolean fromWebinar;

  public static final String SERIALIZED_NAME_HEAD_CLIP = "head_clip";
  @SerializedName(SERIALIZED_NAME_HEAD_CLIP)
  private Object headClip;

  public static final String SERIALIZED_NAME_INTERACTION_TOOLS_SETTINGS = "interaction_tools_settings";
  @SerializedName(SERIALIZED_NAME_INTERACTION_TOOLS_SETTINGS)
  private List<LiveEventInteractionToolsSettingsInner> interactionToolsSettings = new ArrayList<>();

  /**
   * The type of latency.  Option descriptions:  * &#x60;fail-safe&#x60; - The latency is in the failsafe range, with a delay of 60-75 seconds.  * &#x60;low&#x60; - The latency is low, with a delay of 5-7 seconds.  * &#x60;standard&#x60; - The latency is standard, with a delay of 15-20 seconds. 
   */
  @JsonAdapter(LatencyEnum.Adapter.class)
 public enum LatencyEnum {
    FAIL_SAFE("fail-safe"),
    
    LOW("low"),
    
    STANDARD("standard");

    private String value;

    LatencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LatencyEnum fromValue(String value) {
      for (LatencyEnum b : LatencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LatencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LatencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LatencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LatencyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LATENCY = "latency";
  @SerializedName(SERIALIZED_NAME_LATENCY)
  private LatencyEnum latency;

  public static final String SERIALIZED_NAME_LEAD_UUID = "lead_uuid";
  @SerializedName(SERIALIZED_NAME_LEAD_UUID)
  private String leadUuid;

  public static final String SERIALIZED_NAME_LINK = "link";
  @SerializedName(SERIALIZED_NAME_LINK)
  private String link;

  public static final String SERIALIZED_NAME_LIVE_CLIPS = "live_clips";
  @SerializedName(SERIALIZED_NAME_LIVE_CLIPS)
  private List<String> liveClips = new ArrayList<>();

  public static final String SERIALIZED_NAME_LIVE_DESTINATIONS = "live_destinations";
  @SerializedName(SERIALIZED_NAME_LIVE_DESTINATIONS)
  private List<String> liveDestinations = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOW_LATENCY = "low_latency";
  @SerializedName(SERIALIZED_NAME_LOW_LATENCY)
  private Boolean lowLatency;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private LiveEventRecurringMetadata metadata;

  public static final String SERIALIZED_NAME_NEXT_OCCURRENCE_TIME = "next_occurrence_time";
  @SerializedName(SERIALIZED_NAME_NEXT_OCCURRENCE_TIME)
  private String nextOccurrenceTime;

  public static final String SERIALIZED_NAME_PARENT_FOLDER = "parent_folder";
  @SerializedName(SERIALIZED_NAME_PARENT_FOLDER)
  private Project parentFolder;

  public static final String SERIALIZED_NAME_PICTURES = "pictures";
  @SerializedName(SERIALIZED_NAME_PICTURES)
  private Picture pictures;

  /**
   * The order in which the videos inside the event appear in the playlist.  Option descriptions:  * &#x60;added_first&#x60; - The videos appear according to when they were added to the event, with the most recently added first.  * &#x60;added_last&#x60; - The videos appear according to when they were added to the event, with the most recently added last.  * &#x60;alphabetical&#x60; - The videos appear alphabetically by their title.  * &#x60;arranged&#x60; - The videos appear as arranged by the owner of the event.  * &#x60;comments&#x60; - The videos appear according to their number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear according to their number of likes.  * &#x60;newest&#x60; - The videos appear in chronological order, with the newest first.  * &#x60;oldest&#x60; - The videos appear in chronological order, with the oldest first.  * &#x60;plays&#x60; - The videos appear according to their number of plays. 
   */
  @JsonAdapter(PlaylistSortEnum.Adapter.class)
 public enum PlaylistSortEnum {
    ADDED_FIRST("added_first"),
    
    ADDED_LAST("added_last"),
    
    ALPHABETICAL("alphabetical"),
    
    ARRANGED("arranged"),
    
    COMMENTS("comments"),
    
    DURATION("duration"),
    
    LIKES("likes"),
    
    NEWEST("newest"),
    
    OLDEST("oldest"),
    
    PLAYS("plays");

    private String value;

    PlaylistSortEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PlaylistSortEnum fromValue(String value) {
      for (PlaylistSortEnum b : PlaylistSortEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PlaylistSortEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PlaylistSortEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PlaylistSortEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PlaylistSortEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PLAYLIST_SORT = "playlist_sort";
  @SerializedName(SERIALIZED_NAME_PLAYLIST_SORT)
  private PlaylistSortEnum playlistSort;

  /**
   * The preferred streaming method.  Option descriptions:  * &#x60;browser&#x60; - Stream in the browser.  * &#x60;encoder&#x60; - Stream by the encoder. 
   */
  @JsonAdapter(PreferredStreamMethodEnum.Adapter.class)
 public enum PreferredStreamMethodEnum {
    BROWSER("browser"),
    
    ENCODER("encoder");

    private String value;

    PreferredStreamMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PreferredStreamMethodEnum fromValue(String value) {
      for (PreferredStreamMethodEnum b : PreferredStreamMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PreferredStreamMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PreferredStreamMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PreferredStreamMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PreferredStreamMethodEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PREFERRED_STREAM_METHOD = "preferred_stream_method";
  @SerializedName(SERIALIZED_NAME_PREFERRED_STREAM_METHOD)
  private PreferredStreamMethodEnum preferredStreamMethod;

  public static final String SERIALIZED_NAME_RTMP_LINK = "rtmp_link";
  @SerializedName(SERIALIZED_NAME_RTMP_LINK)
  private String rtmpLink;

  public static final String SERIALIZED_NAME_RTMP_PREVIEW = "rtmp_preview";
  @SerializedName(SERIALIZED_NAME_RTMP_PREVIEW)
  private Boolean rtmpPreview;

  public static final String SERIALIZED_NAME_RTMPS_LINK = "rtmps_link";
  @SerializedName(SERIALIZED_NAME_RTMPS_LINK)
  private String rtmpsLink;

  public static final String SERIALIZED_NAME_SCHEDULE = "schedule";
  @SerializedName(SERIALIZED_NAME_SCHEDULE)
  private LiveEventSchedule schedule;

  public static final String SERIALIZED_NAME_SCHEDULED_PLAYBACK = "scheduled_playback";
  @SerializedName(SERIALIZED_NAME_SCHEDULED_PLAYBACK)
  private Boolean scheduledPlayback;

  /**
   * The status of the event.  Option descriptions:  * &#x60;ended&#x60; - The user ended the event.  * &#x60;started&#x60; - The user started the event. 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
 public enum StatusEnum {
    ENDED("ended"),
    
    STARTED("started");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_STREAM_DESCRIPTION = "stream_description";
  @SerializedName(SERIALIZED_NAME_STREAM_DESCRIPTION)
  private String streamDescription;

  public static final String SERIALIZED_NAME_STREAM_KEY = "stream_key";
  @SerializedName(SERIALIZED_NAME_STREAM_KEY)
  private String streamKey;

  /**
   * The stream mode of the event.  Option descriptions:  * &#x60;live&#x60; - The stream is live playback.  * &#x60;record&#x60; - The stream is in record mode.  * &#x60;simulive&#x60; - The stream is scheduled media playback. 
   */
  @JsonAdapter(StreamModeEnum.Adapter.class)
 public enum StreamModeEnum {
    LIVE("live"),
    
    RECORD("record"),
    
    SIMULIVE("simulive");

    private String value;

    StreamModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StreamModeEnum fromValue(String value) {
      for (StreamModeEnum b : StreamModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StreamModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StreamModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StreamModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StreamModeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_STREAM_MODE = "stream_mode";
  @SerializedName(SERIALIZED_NAME_STREAM_MODE)
  private StreamModeEnum streamMode;

  public static final String SERIALIZED_NAME_STREAM_PASSWORD = "stream_password";
  @SerializedName(SERIALIZED_NAME_STREAM_PASSWORD)
  private String streamPassword;

  public static final String SERIALIZED_NAME_STREAM_PRIVACY = "stream_privacy";
  @SerializedName(SERIALIZED_NAME_STREAM_PRIVACY)
  private LiveEventRecurringStreamPrivacy streamPrivacy;

  public static final String SERIALIZED_NAME_STREAM_TITLE = "stream_title";
  @SerializedName(SERIALIZED_NAME_STREAM_TITLE)
  private String streamTitle;

  public static final String SERIALIZED_NAME_STREAMABLE_CLIP = "streamable_clip";
  @SerializedName(SERIALIZED_NAME_STREAMABLE_CLIP)
  private Object streamableClip;

  public static final String SERIALIZED_NAME_TIME_ZONE = "time_zone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public static final String SERIALIZED_NAME_UNLIMITED_AUTO_CC = "unlimited_auto_cc";
  @SerializedName(SERIALIZED_NAME_UNLIMITED_AUTO_CC)
  private Boolean unlimitedAutoCc;

  public static final String SERIALIZED_NAME_UNLIMITED_DURATION = "unlimited_duration";
  @SerializedName(SERIALIZED_NAME_UNLIMITED_DURATION)
  private Boolean unlimitedDuration;

  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  private String uri;

  public static final String SERIALIZED_NAME_USER = "user";
  @SerializedName(SERIALIZED_NAME_USER)
  private User user;

  public static final String SERIALIZED_NAME_VIEW_LINK = "view_link";
  @SerializedName(SERIALIZED_NAME_VIEW_LINK)
  private String viewLink;

  public static final String SERIALIZED_NAME_WEBINAR = "webinar";
  @SerializedName(SERIALIZED_NAME_WEBINAR)
  private List<String> webinar = new ArrayList<>();

  public LiveEventRecurring() {
  }

  public LiveEventRecurring title(String title) {
    
    
    
    
    this.title = title;
    return this;
  }

   /**
   * The title of the event. This field is also optionally used as the base title for videos created by streaming to the event.
   * @return title
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "Live Content", required = true, value = "The title of the event. This field is also optionally used as the base title for videos created by streaming to the event.")

  public String getTitle() {
    return title;
  }


  public void setTitle(String title) {
    
    
    
    this.title = title;
  }


  public LiveEventRecurring album(List<String> album) {
    
    
    
    
    this.album = album;
    return this;
  }

  public LiveEventRecurring addAlbumItem(String albumItem) {
    this.album.add(albumItem);
    return this;
  }

   /**
   * Information about the associated showcase.
   * @return album
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "Information about the associated showcase.")

  public List<String> getAlbum() {
    return album;
  }


  public void setAlbum(List<String> album) {
    
    
    
    this.album = album;
  }


  public LiveEventRecurring allowShareLink(Boolean allowShareLink) {
    
    
    
    
    this.allowShareLink = allowShareLink;
    return this;
  }

   /**
   * Whether the share link for the videos generated by streaming to the event is usable.
   * @return allowShareLink
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the share link for the videos generated by streaming to the event is usable.")

  public Boolean getAllowShareLink() {
    return allowShareLink;
  }


  public void setAllowShareLink(Boolean allowShareLink) {
    
    
    
    this.allowShareLink = allowShareLink;
  }


  public LiveEventRecurring allowedPrivacies(List<String> allowedPrivacies) {
    
    
    
    
    this.allowedPrivacies = allowedPrivacies;
    return this;
  }

  public LiveEventRecurring addAllowedPrivaciesItem(String allowedPrivaciesItem) {
    this.allowedPrivacies.add(allowedPrivaciesItem);
    return this;
  }

   /**
   * An array of privacy settings supported for this event and the requesting user.
   * @return allowedPrivacies
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "An array of privacy settings supported for this event and the requesting user.")

  public List<String> getAllowedPrivacies() {
    return allowedPrivacies;
  }


  public void setAllowedPrivacies(List<String> allowedPrivacies) {
    
    
    
    this.allowedPrivacies = allowedPrivacies;
  }


  public LiveEventRecurring autoCcEnabled(Boolean autoCcEnabled) {
    
    
    
    
    this.autoCcEnabled = autoCcEnabled;
    return this;
  }

   /**
   * Whether the automated closed captions feature is enabled.
   * @return autoCcEnabled
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "Whether the automated closed captions feature is enabled.")

  public Boolean getAutoCcEnabled() {
    return autoCcEnabled;
  }


  public void setAutoCcEnabled(Boolean autoCcEnabled) {
    
    
    
    this.autoCcEnabled = autoCcEnabled;
  }


  public LiveEventRecurring autoCcKeywords(String autoCcKeywords) {
    
    
    
    
    this.autoCcKeywords = autoCcKeywords;
    return this;
  }

   /**
   * A comma-separated list of keywords for enhancing the speech detection of automated closed captions.
   * @return autoCcKeywords
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "A comma-separated list of keywords for enhancing the speech detection of automated closed captions.")

  public String getAutoCcKeywords() {
    return autoCcKeywords;
  }


  public void setAutoCcKeywords(String autoCcKeywords) {
    
    
    
    this.autoCcKeywords = autoCcKeywords;
  }


  public LiveEventRecurring autoCcLanguage(AutoCcLanguageEnum autoCcLanguage) {
    
    
    
    
    this.autoCcLanguage = autoCcLanguage;
    return this;
  }

   /**
   * The language of the automated closed captions.  Option descriptions:  * &#x60;de-DE&#x60; - The language is German.  * &#x60;en-US&#x60; - The language is English.  * &#x60;es-ES&#x60; - The language is Spanish.  * &#x60;fr-FR&#x60; - The language is French.  * &#x60;pt-BR&#x60; - The language is Portuguese. 
   * @return autoCcLanguage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "EN_US", required = true, value = "The language of the automated closed captions.  Option descriptions:  * `de-DE` - The language is German.  * `en-US` - The language is English.  * `es-ES` - The language is Spanish.  * `fr-FR` - The language is French.  * `pt-BR` - The language is Portuguese. ")

  public AutoCcLanguageEnum getAutoCcLanguage() {
    return autoCcLanguage;
  }


  public void setAutoCcLanguage(AutoCcLanguageEnum autoCcLanguage) {
    
    
    
    this.autoCcLanguage = autoCcLanguage;
  }


  public LiveEventRecurring autoCcRemaining(Double autoCcRemaining) {
    
    
    
    
    this.autoCcRemaining = autoCcRemaining;
    return this;
  }

  public LiveEventRecurring autoCcRemaining(Integer autoCcRemaining) {
    
    
    
    
    this.autoCcRemaining = autoCcRemaining.doubleValue();
    return this;
  }

   /**
   * The amount of time remaining to the user to access the automated closed captions feature.
   * @return autoCcRemaining
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The amount of time remaining to the user to access the automated closed captions feature.")

  public Double getAutoCcRemaining() {
    return autoCcRemaining;
  }


  public void setAutoCcRemaining(Double autoCcRemaining) {
    
    
    
    this.autoCcRemaining = autoCcRemaining;
  }


  public LiveEventRecurring automaticallyTitleStream(Boolean automaticallyTitleStream) {
    
    
    
    
    this.automaticallyTitleStream = automaticallyTitleStream;
    return this;
  }

   /**
   * When the value of this field is &#x60;true&#x60;, the title for the next video in the event is generated based on the time of the stream and the **title** field of the event.
   * @return automaticallyTitleStream
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "When the value of this field is `true`, the title for the next video in the event is generated based on the time of the stream and the **title** field of the event.")

  public Boolean getAutomaticallyTitleStream() {
    return automaticallyTitleStream;
  }


  public void setAutomaticallyTitleStream(Boolean automaticallyTitleStream) {
    
    
    
    this.automaticallyTitleStream = automaticallyTitleStream;
  }


  public LiveEventRecurring chatEnabled(Boolean chatEnabled) {
    
    
    
    
    this.chatEnabled = chatEnabled;
    return this;
  }

   /**
   * Whether to display live chat on the event page on Vimeo.
   * @return chatEnabled
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether to display live chat on the event page on Vimeo.")

  public Boolean getChatEnabled() {
    return chatEnabled;
  }


  public void setChatEnabled(Boolean chatEnabled) {
    
    
    
    this.chatEnabled = chatEnabled;
  }


  public LiveEventRecurring completedOn(String completedOn) {
    
    
    
    
    this.completedOn = completedOn;
    return this;
  }

   /**
   * The time in ISO 8601 format when the event was completed.
   * @return completedOn
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "2021-11-11T11:24:56+00:00", required = true, value = "The time in ISO 8601 format when the event was completed.")

  public String getCompletedOn() {
    return completedOn;
  }


  public void setCompletedOn(String completedOn) {
    
    
    
    this.completedOn = completedOn;
  }


  public LiveEventRecurring contentRating(ContentRatingEnum contentRating) {
    
    
    
    
    this.contentRating = contentRating;
    return this;
  }

  public LiveEventRecurring addContentRatingItem(String contentRatingItem) {
    this.contentRating.add(contentRatingItem);
    return this;
  }

   /**
   * The event&#39;s granular content ratings.  Option descriptions:  * &#x60;advertisement&#x60; - The event contains advertisements.  * &#x60;drugs&#x60; - The event contains drug or alcohol use.  * &#x60;language&#x60; - The event contains profanity or sexually suggestive content.  * &#x60;nudity&#x60; - The event contains nudity.  * &#x60;safe&#x60; - The event is safe for all audiences.  * &#x60;unrated&#x60; - The event hasn&#39;t been rated.  * &#x60;violence&#x60; - The event contains violence. 
   * @return contentRating
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The event's granular content ratings.  Option descriptions:  * `advertisement` - The event contains advertisements.  * `drugs` - The event contains drug or alcohol use.  * `language` - The event contains profanity or sexually suggestive content.  * `nudity` - The event contains nudity.  * `safe` - The event is safe for all audiences.  * `unrated` - The event hasn't been rated.  * `violence` - The event contains violence. ")

  public ContentRatingEnum getContentRating() {
    return contentRating;
  }


  public void setContentRating(ContentRatingEnum contentRating) {
    
    
    
    this.contentRating = contentRating;
  }


  public LiveEventRecurring createdTime(String createdTime) {
    
    
    
    
    this.createdTime = createdTime;
    return this;
  }

   /**
   * The time in ISO 8601 format when the event was created.
   * @return createdTime
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "2016-11-03T09:24:56+00:00", required = true, value = "The time in ISO 8601 format when the event was created.")

  public String getCreatedTime() {
    return createdTime;
  }


  public void setCreatedTime(String createdTime) {
    
    
    
    this.createdTime = createdTime;
  }


  public LiveEventRecurring dvr(Boolean dvr) {
    
    
    
    
    this.dvr = dvr;
    return this;
  }

   /**
   * Whether the DVR feature is enabled.
   * @return dvr
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether the DVR feature is enabled.")

  public Boolean getDvr() {
    return dvr;
  }


  public void setDvr(Boolean dvr) {
    
    
    
    this.dvr = dvr;
  }


  public LiveEventRecurring emailQuota(LiveEventRecurringEmailQuota emailQuota) {
    
    
    
    
    this.emailQuota = emailQuota;
    return this;
  }

   /**
   * Get emailQuota
   * @return emailQuota
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LiveEventRecurringEmailQuota getEmailQuota() {
    return emailQuota;
  }


  public void setEmailQuota(LiveEventRecurringEmailQuota emailQuota) {
    
    
    
    this.emailQuota = emailQuota;
  }


  public LiveEventRecurring embed(LiveEventRecurringEmbed embed) {
    
    
    
    
    this.embed = embed;
    return this;
  }

   /**
   * Get embed
   * @return embed
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LiveEventRecurringEmbed getEmbed() {
    return embed;
  }


  public void setEmbed(LiveEventRecurringEmbed embed) {
    
    
    
    this.embed = embed;
  }


  public LiveEventRecurring fromShowcase(Boolean fromShowcase) {
    
    
    
    
    this.fromShowcase = fromShowcase;
    return this;
  }

   /**
   * Whether the event was created from a showcase.
   * @return fromShowcase
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Whether the event was created from a showcase.")

  public Boolean getFromShowcase() {
    return fromShowcase;
  }


  public void setFromShowcase(Boolean fromShowcase) {
    
    
    
    this.fromShowcase = fromShowcase;
  }


  public LiveEventRecurring fromWebinar(Boolean fromWebinar) {
    
    
    
    
    this.fromWebinar = fromWebinar;
    return this;
  }

   /**
   * Whether the event was created from a webinar.
   * @return fromWebinar
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Whether the event was created from a webinar.")

  public Boolean getFromWebinar() {
    return fromWebinar;
  }


  public void setFromWebinar(Boolean fromWebinar) {
    
    
    
    this.fromWebinar = fromWebinar;
  }


  public LiveEventRecurring headClip(Object headClip) {
    
    
    
    
    this.headClip = headClip;
    return this;
  }

   /**
   * The first video to be played in the playlist.
   * @return headClip
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The first video to be played in the playlist.")

  public Object getHeadClip() {
    return headClip;
  }


  public void setHeadClip(Object headClip) {
    
    
    
    this.headClip = headClip;
  }


  public LiveEventRecurring interactionToolsSettings(List<LiveEventInteractionToolsSettingsInner> interactionToolsSettings) {
    
    
    
    
    this.interactionToolsSettings = interactionToolsSettings;
    return this;
  }

  public LiveEventRecurring addInteractionToolsSettingsItem(LiveEventInteractionToolsSettingsInner interactionToolsSettingsItem) {
    this.interactionToolsSettings.add(interactionToolsSettingsItem);
    return this;
  }

   /**
   * The settings for the interaction tools.
   * @return interactionToolsSettings
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The settings for the interaction tools.")

  public List<LiveEventInteractionToolsSettingsInner> getInteractionToolsSettings() {
    return interactionToolsSettings;
  }


  public void setInteractionToolsSettings(List<LiveEventInteractionToolsSettingsInner> interactionToolsSettings) {
    
    
    
    this.interactionToolsSettings = interactionToolsSettings;
  }


  public LiveEventRecurring latency(LatencyEnum latency) {
    
    
    
    
    this.latency = latency;
    return this;
  }

   /**
   * The type of latency.  Option descriptions:  * &#x60;fail-safe&#x60; - The latency is in the failsafe range, with a delay of 60-75 seconds.  * &#x60;low&#x60; - The latency is low, with a delay of 5-7 seconds.  * &#x60;standard&#x60; - The latency is standard, with a delay of 15-20 seconds. 
   * @return latency
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "STANDARD", required = true, value = "The type of latency.  Option descriptions:  * `fail-safe` - The latency is in the failsafe range, with a delay of 60-75 seconds.  * `low` - The latency is low, with a delay of 5-7 seconds.  * `standard` - The latency is standard, with a delay of 15-20 seconds. ")

  public LatencyEnum getLatency() {
    return latency;
  }


  public void setLatency(LatencyEnum latency) {
    
    
    
    this.latency = latency;
  }


  public LiveEventRecurring leadUuid(String leadUuid) {
    
    
    
    
    this.leadUuid = leadUuid;
    return this;
  }

   /**
   * The unique ID for the registered viewer.
   * @return leadUuid
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The unique ID for the registered viewer.")

  public String getLeadUuid() {
    return leadUuid;
  }


  public void setLeadUuid(String leadUuid) {
    
    
    
    this.leadUuid = leadUuid;
  }


  public LiveEventRecurring link(String link) {
    
    
    
    
    this.link = link;
    return this;
  }

   /**
   * The URI to access the event on Vimeo.
   * @return link
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "/events/12345", required = true, value = "The URI to access the event on Vimeo.")

  public String getLink() {
    return link;
  }


  public void setLink(String link) {
    
    
    
    this.link = link;
  }


  public LiveEventRecurring liveClips(List<String> liveClips) {
    
    
    
    
    this.liveClips = liveClips;
    return this;
  }

  public LiveEventRecurring addLiveClipsItem(String liveClipsItem) {
    this.liveClips.add(liveClipsItem);
    return this;
  }

   /**
   * A list of videos belonging to the event, including their video IDs and dates streamed.
   * @return liveClips
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of videos belonging to the event, including their video IDs and dates streamed.")

  public List<String> getLiveClips() {
    return liveClips;
  }


  public void setLiveClips(List<String> liveClips) {
    
    
    
    this.liveClips = liveClips;
  }


  public LiveEventRecurring liveDestinations(List<String> liveDestinations) {
    
    
    
    
    this.liveDestinations = liveDestinations;
    return this;
  }

  public LiveEventRecurring addLiveDestinationsItem(String liveDestinationsItem) {
    this.liveDestinations.add(liveDestinationsItem);
    return this;
  }

   /**
   * _This field is deprecated in favor of the following method:_ [Get all the destinations of a one-time live event](https://developer.vimeo.com/api/reference/live#get_one_time_event_destinations).
   * @return liveDestinations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "_This field is deprecated in favor of the following method:_ [Get all the destinations of a one-time live event](https://developer.vimeo.com/api/reference/live#get_one_time_event_destinations).")

  public List<String> getLiveDestinations() {
    return liveDestinations;
  }


  public void setLiveDestinations(List<String> liveDestinations) {
    
    
    
    this.liveDestinations = liveDestinations;
  }


  public LiveEventRecurring lowLatency(Boolean lowLatency) {
    
    
    
    
    this.lowLatency = lowLatency;
    return this;
  }

   /**
   * Whether the low-latency feature is enabled.
   * @return lowLatency
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "false", required = true, value = "Whether the low-latency feature is enabled.")

  public Boolean getLowLatency() {
    return lowLatency;
  }


  public void setLowLatency(Boolean lowLatency) {
    
    
    
    this.lowLatency = lowLatency;
  }


  public LiveEventRecurring metadata(LiveEventRecurringMetadata metadata) {
    
    
    
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LiveEventRecurringMetadata getMetadata() {
    return metadata;
  }


  public void setMetadata(LiveEventRecurringMetadata metadata) {
    
    
    
    this.metadata = metadata;
  }


  public LiveEventRecurring nextOccurrenceTime(String nextOccurrenceTime) {
    
    
    
    
    this.nextOccurrenceTime = nextOccurrenceTime;
    return this;
  }

   /**
   * The date in ISO 8601 format on which the next occurrence of the event is expected to be live.
   * @return nextOccurrenceTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2018-07-30T14:00:00+00:00", required = true, value = "The date in ISO 8601 format on which the next occurrence of the event is expected to be live.")

  public String getNextOccurrenceTime() {
    return nextOccurrenceTime;
  }


  public void setNextOccurrenceTime(String nextOccurrenceTime) {
    
    
    
    this.nextOccurrenceTime = nextOccurrenceTime;
  }


  public LiveEventRecurring parentFolder(Project parentFolder) {
    
    
    
    
    this.parentFolder = parentFolder;
    return this;
  }

   /**
   * Information about the folder that contains the event.
   * @return parentFolder
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Information about the folder that contains the event.")

  public Project getParentFolder() {
    return parentFolder;
  }


  public void setParentFolder(Project parentFolder) {
    
    
    
    this.parentFolder = parentFolder;
  }


  public LiveEventRecurring pictures(Picture pictures) {
    
    
    
    
    this.pictures = pictures;
    return this;
  }

   /**
   * The active thumbnail image of the event.
   * @return pictures
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The active thumbnail image of the event.")

  public Picture getPictures() {
    return pictures;
  }


  public void setPictures(Picture pictures) {
    
    
    
    this.pictures = pictures;
  }


  public LiveEventRecurring playlistSort(PlaylistSortEnum playlistSort) {
    
    
    
    
    this.playlistSort = playlistSort;
    return this;
  }

   /**
   * The order in which the videos inside the event appear in the playlist.  Option descriptions:  * &#x60;added_first&#x60; - The videos appear according to when they were added to the event, with the most recently added first.  * &#x60;added_last&#x60; - The videos appear according to when they were added to the event, with the most recently added last.  * &#x60;alphabetical&#x60; - The videos appear alphabetically by their title.  * &#x60;arranged&#x60; - The videos appear as arranged by the owner of the event.  * &#x60;comments&#x60; - The videos appear according to their number of comments.  * &#x60;duration&#x60; - The videos appear in order of duration.  * &#x60;likes&#x60; - The videos appear according to their number of likes.  * &#x60;newest&#x60; - The videos appear in chronological order, with the newest first.  * &#x60;oldest&#x60; - The videos appear in chronological order, with the oldest first.  * &#x60;plays&#x60; - The videos appear according to their number of plays. 
   * @return playlistSort
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "ADDED_FIRST", required = true, value = "The order in which the videos inside the event appear in the playlist.  Option descriptions:  * `added_first` - The videos appear according to when they were added to the event, with the most recently added first.  * `added_last` - The videos appear according to when they were added to the event, with the most recently added last.  * `alphabetical` - The videos appear alphabetically by their title.  * `arranged` - The videos appear as arranged by the owner of the event.  * `comments` - The videos appear according to their number of comments.  * `duration` - The videos appear in order of duration.  * `likes` - The videos appear according to their number of likes.  * `newest` - The videos appear in chronological order, with the newest first.  * `oldest` - The videos appear in chronological order, with the oldest first.  * `plays` - The videos appear according to their number of plays. ")

  public PlaylistSortEnum getPlaylistSort() {
    return playlistSort;
  }


  public void setPlaylistSort(PlaylistSortEnum playlistSort) {
    
    
    
    this.playlistSort = playlistSort;
  }


  public LiveEventRecurring preferredStreamMethod(PreferredStreamMethodEnum preferredStreamMethod) {
    
    
    
    
    this.preferredStreamMethod = preferredStreamMethod;
    return this;
  }

   /**
   * The preferred streaming method.  Option descriptions:  * &#x60;browser&#x60; - Stream in the browser.  * &#x60;encoder&#x60; - Stream by the encoder. 
   * @return preferredStreamMethod
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "ENCODER", required = true, value = "The preferred streaming method.  Option descriptions:  * `browser` - Stream in the browser.  * `encoder` - Stream by the encoder. ")

  public PreferredStreamMethodEnum getPreferredStreamMethod() {
    return preferredStreamMethod;
  }


  public void setPreferredStreamMethod(PreferredStreamMethodEnum preferredStreamMethod) {
    
    
    
    this.preferredStreamMethod = preferredStreamMethod;
  }


  public LiveEventRecurring rtmpLink(String rtmpLink) {
    
    
    
    
    this.rtmpLink = rtmpLink;
    return this;
  }

   /**
   * The upstream RTMP link. Send your live content to this link to create a live video on the event.
   * @return rtmpLink
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "rtmp://rtmp.cloud.vimeo.com/live", required = true, value = "The upstream RTMP link. Send your live content to this link to create a live video on the event.")

  public String getRtmpLink() {
    return rtmpLink;
  }


  public void setRtmpLink(String rtmpLink) {
    
    
    
    this.rtmpLink = rtmpLink;
  }


  public LiveEventRecurring rtmpPreview(Boolean rtmpPreview) {
    
    
    
    
    this.rtmpPreview = rtmpPreview;
    return this;
  }

   /**
   * Whether to preview the RTMP stream before the event goes live.
   * @return rtmpPreview
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether to preview the RTMP stream before the event goes live.")

  public Boolean getRtmpPreview() {
    return rtmpPreview;
  }


  public void setRtmpPreview(Boolean rtmpPreview) {
    
    
    
    this.rtmpPreview = rtmpPreview;
  }


  public LiveEventRecurring rtmpsLink(String rtmpsLink) {
    
    
    
    
    this.rtmpsLink = rtmpsLink;
    return this;
  }

   /**
   * The upstream RTMPS link. Send your live content to this link to create a live video on the event.
   * @return rtmpsLink
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "rtmps://rtmp.cloud.vimeo.com/live", required = true, value = "The upstream RTMPS link. Send your live content to this link to create a live video on the event.")

  public String getRtmpsLink() {
    return rtmpsLink;
  }


  public void setRtmpsLink(String rtmpsLink) {
    
    
    
    this.rtmpsLink = rtmpsLink;
  }


  public LiveEventRecurring schedule(LiveEventSchedule schedule) {
    
    
    
    
    this.schedule = schedule;
    return this;
  }

   /**
   * The description of the time or times that the event is expected to be live.
   * @return schedule
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The description of the time or times that the event is expected to be live.")

  public LiveEventSchedule getSchedule() {
    return schedule;
  }


  public void setSchedule(LiveEventSchedule schedule) {
    
    
    
    this.schedule = schedule;
  }


  public LiveEventRecurring scheduledPlayback(Boolean scheduledPlayback) {
    
    
    
    
    this.scheduledPlayback = scheduledPlayback;
    return this;
  }

   /**
   * Whether the scheduled playback feature is enabled.
   * @return scheduledPlayback
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "false", required = true, value = "Whether the scheduled playback feature is enabled.")

  public Boolean getScheduledPlayback() {
    return scheduledPlayback;
  }


  public void setScheduledPlayback(Boolean scheduledPlayback) {
    
    
    
    this.scheduledPlayback = scheduledPlayback;
  }


  public LiveEventRecurring status(StatusEnum status) {
    
    
    
    
    this.status = status;
    return this;
  }

   /**
   * The status of the event.  Option descriptions:  * &#x60;ended&#x60; - The user ended the event.  * &#x60;started&#x60; - The user started the event. 
   * @return status
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "STARTED", required = true, value = "The status of the event.  Option descriptions:  * `ended` - The user ended the event.  * `started` - The user started the event. ")

  public StatusEnum getStatus() {
    return status;
  }


  public void setStatus(StatusEnum status) {
    
    
    
    this.status = status;
  }


  public LiveEventRecurring streamDescription(String streamDescription) {
    
    
    
    
    this.streamDescription = streamDescription;
    return this;
  }

   /**
   * The description of the next video streamed to the event.
   * @return streamDescription
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "In this episode, we interview a surprise guest", required = true, value = "The description of the next video streamed to the event.")

  public String getStreamDescription() {
    return streamDescription;
  }


  public void setStreamDescription(String streamDescription) {
    
    
    
    this.streamDescription = streamDescription;
  }


  public LiveEventRecurring streamKey(String streamKey) {
    
    
    
    
    this.streamKey = streamKey;
    return this;
  }

   /**
   * The stream key used in conjunction with the RTMP and RTMPS links.
   * @return streamKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "ab9c8def-7a65-4321-b098-c7dd65e43f21", required = true, value = "The stream key used in conjunction with the RTMP and RTMPS links.")

  public String getStreamKey() {
    return streamKey;
  }


  public void setStreamKey(String streamKey) {
    
    
    
    this.streamKey = streamKey;
  }


  public LiveEventRecurring streamMode(StreamModeEnum streamMode) {
    
    
    
    
    this.streamMode = streamMode;
    return this;
  }

   /**
   * The stream mode of the event.  Option descriptions:  * &#x60;live&#x60; - The stream is live playback.  * &#x60;record&#x60; - The stream is in record mode.  * &#x60;simulive&#x60; - The stream is scheduled media playback. 
   * @return streamMode
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "LIVE", required = true, value = "The stream mode of the event.  Option descriptions:  * `live` - The stream is live playback.  * `record` - The stream is in record mode.  * `simulive` - The stream is scheduled media playback. ")

  public StreamModeEnum getStreamMode() {
    return streamMode;
  }


  public void setStreamMode(StreamModeEnum streamMode) {
    
    
    
    this.streamMode = streamMode;
  }


  public LiveEventRecurring streamPassword(String streamPassword) {
    
    
    
    
    this.streamPassword = streamPassword;
    return this;
  }

   /**
   * The password that anyone can use to access the videos generated by streaming to the event.
   * @return streamPassword
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "hunter1", required = true, value = "The password that anyone can use to access the videos generated by streaming to the event.")

  public String getStreamPassword() {
    return streamPassword;
  }


  public void setStreamPassword(String streamPassword) {
    
    
    
    this.streamPassword = streamPassword;
  }


  public LiveEventRecurring streamPrivacy(LiveEventRecurringStreamPrivacy streamPrivacy) {
    
    
    
    
    this.streamPrivacy = streamPrivacy;
    return this;
  }

   /**
   * Get streamPrivacy
   * @return streamPrivacy
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public LiveEventRecurringStreamPrivacy getStreamPrivacy() {
    return streamPrivacy;
  }


  public void setStreamPrivacy(LiveEventRecurringStreamPrivacy streamPrivacy) {
    
    
    
    this.streamPrivacy = streamPrivacy;
  }


  public LiveEventRecurring streamTitle(String streamTitle) {
    
    
    
    
    this.streamTitle = streamTitle;
    return this;
  }

   /**
   * The title of the next video streamed to the event. This field applies only when **automatically_title_stream** is &#x60;false&#x60;.
   * @return streamTitle
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "Special Feature", required = true, value = "The title of the next video streamed to the event. This field applies only when **automatically_title_stream** is `false`.")

  public String getStreamTitle() {
    return streamTitle;
  }


  public void setStreamTitle(String streamTitle) {
    
    
    
    this.streamTitle = streamTitle;
  }


  public LiveEventRecurring streamableClip(Object streamableClip) {
    
    
    
    
    this.streamableClip = streamableClip;
    return this;
  }

   /**
   * The event&#39;s video. An event always has a video, which is either in a pre-live state (ready to be streamed to) or in a live state (which is currently being streamed to).
   * @return streamableClip
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The event's video. An event always has a video, which is either in a pre-live state (ready to be streamed to) or in a live state (which is currently being streamed to).")

  public Object getStreamableClip() {
    return streamableClip;
  }


  public void setStreamableClip(Object streamableClip) {
    
    
    
    this.streamableClip = streamableClip;
  }


  public LiveEventRecurring timeZone(String timeZone) {
    
    
    
    
    this.timeZone = timeZone;
    return this;
  }

   /**
   * The time zone used in resolving the timestamps included in auto-generated video titles.
   * @return timeZone
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "America/New_York", required = true, value = "The time zone used in resolving the timestamps included in auto-generated video titles.")

  public String getTimeZone() {
    return timeZone;
  }


  public void setTimeZone(String timeZone) {
    
    
    
    this.timeZone = timeZone;
  }


  public LiveEventRecurring unlimitedAutoCc(Boolean unlimitedAutoCc) {
    
    
    
    
    this.unlimitedAutoCc = unlimitedAutoCc;
    return this;
  }

   /**
   * Whether to ignore the time limit of the automated closed captions feature.
   * @return unlimitedAutoCc
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "Whether to ignore the time limit of the automated closed captions feature.")

  public Boolean getUnlimitedAutoCc() {
    return unlimitedAutoCc;
  }


  public void setUnlimitedAutoCc(Boolean unlimitedAutoCc) {
    
    
    
    this.unlimitedAutoCc = unlimitedAutoCc;
  }


  public LiveEventRecurring unlimitedDuration(Boolean unlimitedDuration) {
    
    
    
    
    this.unlimitedDuration = unlimitedDuration;
    return this;
  }

   /**
   * Whether 24/7 streaming is enabled for the event.
   * @return unlimitedDuration
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "true", required = true, value = "Whether 24/7 streaming is enabled for the event.")

  public Boolean getUnlimitedDuration() {
    return unlimitedDuration;
  }


  public void setUnlimitedDuration(Boolean unlimitedDuration) {
    
    
    
    this.unlimitedDuration = unlimitedDuration;
  }


  public LiveEventRecurring uri(String uri) {
    
    
    
    
    this.uri = uri;
    return this;
  }

   /**
   * The event&#39;s canonical relative URI.
   * @return uri
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "/live_events/12345", required = true, value = "The event's canonical relative URI.")

  public String getUri() {
    return uri;
  }


  public void setUri(String uri) {
    
    
    
    this.uri = uri;
  }


  public LiveEventRecurring user(User user) {
    
    
    
    
    this.user = user;
    return this;
  }

   /**
   * The owner of the event.
   * @return user
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The owner of the event.")

  public User getUser() {
    return user;
  }


  public void setUser(User user) {
    
    
    
    this.user = user;
  }


  public LiveEventRecurring viewLink(String viewLink) {
    
    
    
    
    this.viewLink = viewLink;
    return this;
  }

   /**
   * The URI to access the event on Vimeo with or without an unlisted hash.
   * @return viewLink
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "/events/12345", required = true, value = "The URI to access the event on Vimeo with or without an unlisted hash.")

  public String getViewLink() {
    return viewLink;
  }


  public void setViewLink(String viewLink) {
    
    
    
    this.viewLink = viewLink;
  }


  public LiveEventRecurring webinar(List<String> webinar) {
    
    
    
    
    this.webinar = webinar;
    return this;
  }

  public LiveEventRecurring addWebinarItem(String webinarItem) {
    this.webinar.add(webinarItem);
    return this;
  }

   /**
   * Information about the associated webinar.
   * @return webinar
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "Information about the associated webinar.")

  public List<String> getWebinar() {
    return webinar;
  }


  public void setWebinar(List<String> webinar) {
    
    
    
    this.webinar = webinar;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the LiveEventRecurring instance itself
   */
  public LiveEventRecurring putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LiveEventRecurring liveEventRecurring = (LiveEventRecurring) o;
    return Objects.equals(this.title, liveEventRecurring.title) &&
        Objects.equals(this.album, liveEventRecurring.album) &&
        Objects.equals(this.allowShareLink, liveEventRecurring.allowShareLink) &&
        Objects.equals(this.allowedPrivacies, liveEventRecurring.allowedPrivacies) &&
        Objects.equals(this.autoCcEnabled, liveEventRecurring.autoCcEnabled) &&
        Objects.equals(this.autoCcKeywords, liveEventRecurring.autoCcKeywords) &&
        Objects.equals(this.autoCcLanguage, liveEventRecurring.autoCcLanguage) &&
        Objects.equals(this.autoCcRemaining, liveEventRecurring.autoCcRemaining) &&
        Objects.equals(this.automaticallyTitleStream, liveEventRecurring.automaticallyTitleStream) &&
        Objects.equals(this.chatEnabled, liveEventRecurring.chatEnabled) &&
        Objects.equals(this.completedOn, liveEventRecurring.completedOn) &&
        Objects.equals(this.contentRating, liveEventRecurring.contentRating) &&
        Objects.equals(this.createdTime, liveEventRecurring.createdTime) &&
        Objects.equals(this.dvr, liveEventRecurring.dvr) &&
        Objects.equals(this.emailQuota, liveEventRecurring.emailQuota) &&
        Objects.equals(this.embed, liveEventRecurring.embed) &&
        Objects.equals(this.fromShowcase, liveEventRecurring.fromShowcase) &&
        Objects.equals(this.fromWebinar, liveEventRecurring.fromWebinar) &&
        Objects.equals(this.headClip, liveEventRecurring.headClip) &&
        Objects.equals(this.interactionToolsSettings, liveEventRecurring.interactionToolsSettings) &&
        Objects.equals(this.latency, liveEventRecurring.latency) &&
        Objects.equals(this.leadUuid, liveEventRecurring.leadUuid) &&
        Objects.equals(this.link, liveEventRecurring.link) &&
        Objects.equals(this.liveClips, liveEventRecurring.liveClips) &&
        Objects.equals(this.liveDestinations, liveEventRecurring.liveDestinations) &&
        Objects.equals(this.lowLatency, liveEventRecurring.lowLatency) &&
        Objects.equals(this.metadata, liveEventRecurring.metadata) &&
        Objects.equals(this.nextOccurrenceTime, liveEventRecurring.nextOccurrenceTime) &&
        Objects.equals(this.parentFolder, liveEventRecurring.parentFolder) &&
        Objects.equals(this.pictures, liveEventRecurring.pictures) &&
        Objects.equals(this.playlistSort, liveEventRecurring.playlistSort) &&
        Objects.equals(this.preferredStreamMethod, liveEventRecurring.preferredStreamMethod) &&
        Objects.equals(this.rtmpLink, liveEventRecurring.rtmpLink) &&
        Objects.equals(this.rtmpPreview, liveEventRecurring.rtmpPreview) &&
        Objects.equals(this.rtmpsLink, liveEventRecurring.rtmpsLink) &&
        Objects.equals(this.schedule, liveEventRecurring.schedule) &&
        Objects.equals(this.scheduledPlayback, liveEventRecurring.scheduledPlayback) &&
        Objects.equals(this.status, liveEventRecurring.status) &&
        Objects.equals(this.streamDescription, liveEventRecurring.streamDescription) &&
        Objects.equals(this.streamKey, liveEventRecurring.streamKey) &&
        Objects.equals(this.streamMode, liveEventRecurring.streamMode) &&
        Objects.equals(this.streamPassword, liveEventRecurring.streamPassword) &&
        Objects.equals(this.streamPrivacy, liveEventRecurring.streamPrivacy) &&
        Objects.equals(this.streamTitle, liveEventRecurring.streamTitle) &&
        Objects.equals(this.streamableClip, liveEventRecurring.streamableClip) &&
        Objects.equals(this.timeZone, liveEventRecurring.timeZone) &&
        Objects.equals(this.unlimitedAutoCc, liveEventRecurring.unlimitedAutoCc) &&
        Objects.equals(this.unlimitedDuration, liveEventRecurring.unlimitedDuration) &&
        Objects.equals(this.uri, liveEventRecurring.uri) &&
        Objects.equals(this.user, liveEventRecurring.user) &&
        Objects.equals(this.viewLink, liveEventRecurring.viewLink) &&
        Objects.equals(this.webinar, liveEventRecurring.webinar)&&
        Objects.equals(this.additionalProperties, liveEventRecurring.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(title, album, allowShareLink, allowedPrivacies, autoCcEnabled, autoCcKeywords, autoCcLanguage, autoCcRemaining, automaticallyTitleStream, chatEnabled, completedOn, contentRating, createdTime, dvr, emailQuota, embed, fromShowcase, fromWebinar, headClip, interactionToolsSettings, latency, leadUuid, link, liveClips, liveDestinations, lowLatency, metadata, nextOccurrenceTime, parentFolder, pictures, playlistSort, preferredStreamMethod, rtmpLink, rtmpPreview, rtmpsLink, schedule, scheduledPlayback, status, streamDescription, streamKey, streamMode, streamPassword, streamPrivacy, streamTitle, streamableClip, timeZone, unlimitedAutoCc, unlimitedDuration, uri, user, viewLink, webinar, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LiveEventRecurring {\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    album: ").append(toIndentedString(album)).append("\n");
    sb.append("    allowShareLink: ").append(toIndentedString(allowShareLink)).append("\n");
    sb.append("    allowedPrivacies: ").append(toIndentedString(allowedPrivacies)).append("\n");
    sb.append("    autoCcEnabled: ").append(toIndentedString(autoCcEnabled)).append("\n");
    sb.append("    autoCcKeywords: ").append(toIndentedString(autoCcKeywords)).append("\n");
    sb.append("    autoCcLanguage: ").append(toIndentedString(autoCcLanguage)).append("\n");
    sb.append("    autoCcRemaining: ").append(toIndentedString(autoCcRemaining)).append("\n");
    sb.append("    automaticallyTitleStream: ").append(toIndentedString(automaticallyTitleStream)).append("\n");
    sb.append("    chatEnabled: ").append(toIndentedString(chatEnabled)).append("\n");
    sb.append("    completedOn: ").append(toIndentedString(completedOn)).append("\n");
    sb.append("    contentRating: ").append(toIndentedString(contentRating)).append("\n");
    sb.append("    createdTime: ").append(toIndentedString(createdTime)).append("\n");
    sb.append("    dvr: ").append(toIndentedString(dvr)).append("\n");
    sb.append("    emailQuota: ").append(toIndentedString(emailQuota)).append("\n");
    sb.append("    embed: ").append(toIndentedString(embed)).append("\n");
    sb.append("    fromShowcase: ").append(toIndentedString(fromShowcase)).append("\n");
    sb.append("    fromWebinar: ").append(toIndentedString(fromWebinar)).append("\n");
    sb.append("    headClip: ").append(toIndentedString(headClip)).append("\n");
    sb.append("    interactionToolsSettings: ").append(toIndentedString(interactionToolsSettings)).append("\n");
    sb.append("    latency: ").append(toIndentedString(latency)).append("\n");
    sb.append("    leadUuid: ").append(toIndentedString(leadUuid)).append("\n");
    sb.append("    link: ").append(toIndentedString(link)).append("\n");
    sb.append("    liveClips: ").append(toIndentedString(liveClips)).append("\n");
    sb.append("    liveDestinations: ").append(toIndentedString(liveDestinations)).append("\n");
    sb.append("    lowLatency: ").append(toIndentedString(lowLatency)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    nextOccurrenceTime: ").append(toIndentedString(nextOccurrenceTime)).append("\n");
    sb.append("    parentFolder: ").append(toIndentedString(parentFolder)).append("\n");
    sb.append("    pictures: ").append(toIndentedString(pictures)).append("\n");
    sb.append("    playlistSort: ").append(toIndentedString(playlistSort)).append("\n");
    sb.append("    preferredStreamMethod: ").append(toIndentedString(preferredStreamMethod)).append("\n");
    sb.append("    rtmpLink: ").append(toIndentedString(rtmpLink)).append("\n");
    sb.append("    rtmpPreview: ").append(toIndentedString(rtmpPreview)).append("\n");
    sb.append("    rtmpsLink: ").append(toIndentedString(rtmpsLink)).append("\n");
    sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
    sb.append("    scheduledPlayback: ").append(toIndentedString(scheduledPlayback)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    streamDescription: ").append(toIndentedString(streamDescription)).append("\n");
    sb.append("    streamKey: ").append(toIndentedString(streamKey)).append("\n");
    sb.append("    streamMode: ").append(toIndentedString(streamMode)).append("\n");
    sb.append("    streamPassword: ").append(toIndentedString(streamPassword)).append("\n");
    sb.append("    streamPrivacy: ").append(toIndentedString(streamPrivacy)).append("\n");
    sb.append("    streamTitle: ").append(toIndentedString(streamTitle)).append("\n");
    sb.append("    streamableClip: ").append(toIndentedString(streamableClip)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("    unlimitedAutoCc: ").append(toIndentedString(unlimitedAutoCc)).append("\n");
    sb.append("    unlimitedDuration: ").append(toIndentedString(unlimitedDuration)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    viewLink: ").append(toIndentedString(viewLink)).append("\n");
    sb.append("    webinar: ").append(toIndentedString(webinar)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("title");
    openapiFields.add("album");
    openapiFields.add("allow_share_link");
    openapiFields.add("allowed_privacies");
    openapiFields.add("auto_cc_enabled");
    openapiFields.add("auto_cc_keywords");
    openapiFields.add("auto_cc_language");
    openapiFields.add("auto_cc_remaining");
    openapiFields.add("automatically_title_stream");
    openapiFields.add("chat_enabled");
    openapiFields.add("completed_on");
    openapiFields.add("content_rating");
    openapiFields.add("created_time");
    openapiFields.add("dvr");
    openapiFields.add("email_quota");
    openapiFields.add("embed");
    openapiFields.add("from_showcase");
    openapiFields.add("from_webinar");
    openapiFields.add("head_clip");
    openapiFields.add("interaction_tools_settings");
    openapiFields.add("latency");
    openapiFields.add("lead_uuid");
    openapiFields.add("link");
    openapiFields.add("live_clips");
    openapiFields.add("live_destinations");
    openapiFields.add("low_latency");
    openapiFields.add("metadata");
    openapiFields.add("next_occurrence_time");
    openapiFields.add("parent_folder");
    openapiFields.add("pictures");
    openapiFields.add("playlist_sort");
    openapiFields.add("preferred_stream_method");
    openapiFields.add("rtmp_link");
    openapiFields.add("rtmp_preview");
    openapiFields.add("rtmps_link");
    openapiFields.add("schedule");
    openapiFields.add("scheduled_playback");
    openapiFields.add("status");
    openapiFields.add("stream_description");
    openapiFields.add("stream_key");
    openapiFields.add("stream_mode");
    openapiFields.add("stream_password");
    openapiFields.add("stream_privacy");
    openapiFields.add("stream_title");
    openapiFields.add("streamable_clip");
    openapiFields.add("time_zone");
    openapiFields.add("unlimited_auto_cc");
    openapiFields.add("unlimited_duration");
    openapiFields.add("uri");
    openapiFields.add("user");
    openapiFields.add("view_link");
    openapiFields.add("webinar");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("title");
    openapiRequiredFields.add("album");
    openapiRequiredFields.add("allow_share_link");
    openapiRequiredFields.add("allowed_privacies");
    openapiRequiredFields.add("auto_cc_enabled");
    openapiRequiredFields.add("auto_cc_keywords");
    openapiRequiredFields.add("auto_cc_language");
    openapiRequiredFields.add("auto_cc_remaining");
    openapiRequiredFields.add("automatically_title_stream");
    openapiRequiredFields.add("chat_enabled");
    openapiRequiredFields.add("completed_on");
    openapiRequiredFields.add("content_rating");
    openapiRequiredFields.add("created_time");
    openapiRequiredFields.add("dvr");
    openapiRequiredFields.add("email_quota");
    openapiRequiredFields.add("embed");
    openapiRequiredFields.add("from_showcase");
    openapiRequiredFields.add("head_clip");
    openapiRequiredFields.add("interaction_tools_settings");
    openapiRequiredFields.add("latency");
    openapiRequiredFields.add("lead_uuid");
    openapiRequiredFields.add("link");
    openapiRequiredFields.add("live_clips");
    openapiRequiredFields.add("live_destinations");
    openapiRequiredFields.add("low_latency");
    openapiRequiredFields.add("metadata");
    openapiRequiredFields.add("next_occurrence_time");
    openapiRequiredFields.add("parent_folder");
    openapiRequiredFields.add("pictures");
    openapiRequiredFields.add("playlist_sort");
    openapiRequiredFields.add("preferred_stream_method");
    openapiRequiredFields.add("rtmp_link");
    openapiRequiredFields.add("rtmp_preview");
    openapiRequiredFields.add("rtmps_link");
    openapiRequiredFields.add("schedule");
    openapiRequiredFields.add("scheduled_playback");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("stream_description");
    openapiRequiredFields.add("stream_key");
    openapiRequiredFields.add("stream_mode");
    openapiRequiredFields.add("stream_password");
    openapiRequiredFields.add("stream_privacy");
    openapiRequiredFields.add("stream_title");
    openapiRequiredFields.add("streamable_clip");
    openapiRequiredFields.add("time_zone");
    openapiRequiredFields.add("unlimited_auto_cc");
    openapiRequiredFields.add("unlimited_duration");
    openapiRequiredFields.add("uri");
    openapiRequiredFields.add("user");
    openapiRequiredFields.add("view_link");
    openapiRequiredFields.add("webinar");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to LiveEventRecurring
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!LiveEventRecurring.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LiveEventRecurring is not found in the empty JSON string", LiveEventRecurring.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LiveEventRecurring.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("album") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("album").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `album` to be an array in the JSON string but got `%s`", jsonObj.get("album").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("allowed_privacies") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("allowed_privacies").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowed_privacies` to be an array in the JSON string but got `%s`", jsonObj.get("allowed_privacies").toString()));
      }
      if (!jsonObj.get("auto_cc_keywords").isJsonNull() && !jsonObj.get("auto_cc_keywords").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `auto_cc_keywords` to be a primitive type in the JSON string but got `%s`", jsonObj.get("auto_cc_keywords").toString()));
      }
      if (!jsonObj.get("auto_cc_language").isJsonNull() && !jsonObj.get("auto_cc_language").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `auto_cc_language` to be a primitive type in the JSON string but got `%s`", jsonObj.get("auto_cc_language").toString()));
      }
      if (!jsonObj.get("completed_on").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completed_on` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completed_on").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("content_rating") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("content_rating").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `content_rating` to be an array in the JSON string but got `%s`", jsonObj.get("content_rating").toString()));
      }
      if (!jsonObj.get("created_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `created_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("created_time").toString()));
      }
      // validate the required field `email_quota`
      LiveEventRecurringEmailQuota.validateJsonObject(jsonObj.getAsJsonObject("email_quota"));
      // validate the required field `embed`
      LiveEventRecurringEmbed.validateJsonObject(jsonObj.getAsJsonObject("embed"));
      // ensure the json data is an array
      if (!jsonObj.get("interaction_tools_settings").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `interaction_tools_settings` to be an array in the JSON string but got `%s`", jsonObj.get("interaction_tools_settings").toString()));
      }

      JsonArray jsonArrayinteractionToolsSettings = jsonObj.getAsJsonArray("interaction_tools_settings");
      // validate the required field `interaction_tools_settings` (array)
      for (int i = 0; i < jsonArrayinteractionToolsSettings.size(); i++) {
        LiveEventInteractionToolsSettingsInner.validateJsonObject(jsonArrayinteractionToolsSettings.get(i).getAsJsonObject());
      };
      if (!jsonObj.get("latency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `latency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("latency").toString()));
      }
      if (!jsonObj.get("lead_uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lead_uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lead_uuid").toString()));
      }
      if (!jsonObj.get("link").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `link` to be a primitive type in the JSON string but got `%s`", jsonObj.get("link").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("live_clips") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("live_clips").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `live_clips` to be an array in the JSON string but got `%s`", jsonObj.get("live_clips").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("live_destinations") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("live_destinations").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `live_destinations` to be an array in the JSON string but got `%s`", jsonObj.get("live_destinations").toString()));
      }
      // validate the required field `metadata`
      LiveEventRecurringMetadata.validateJsonObject(jsonObj.getAsJsonObject("metadata"));
      if (!jsonObj.get("next_occurrence_time").isJsonNull() && !jsonObj.get("next_occurrence_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `next_occurrence_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("next_occurrence_time").toString()));
      }
      // validate the required field `parent_folder`
      Project.validateJsonObject(jsonObj.getAsJsonObject("parent_folder"));
      // validate the required field `pictures`
      Picture.validateJsonObject(jsonObj.getAsJsonObject("pictures"));
      if (!jsonObj.get("playlist_sort").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `playlist_sort` to be a primitive type in the JSON string but got `%s`", jsonObj.get("playlist_sort").toString()));
      }
      if (!jsonObj.get("preferred_stream_method").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferred_stream_method` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preferred_stream_method").toString()));
      }
      if (!jsonObj.get("rtmp_link").isJsonNull() && !jsonObj.get("rtmp_link").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rtmp_link` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rtmp_link").toString()));
      }
      if (!jsonObj.get("rtmps_link").isJsonNull() && !jsonObj.get("rtmps_link").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rtmps_link` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rtmps_link").toString()));
      }
      // validate the required field `schedule`
      LiveEventSchedule.validateJsonObject(jsonObj.getAsJsonObject("schedule"));
      if (!jsonObj.get("status").isJsonNull() && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (!jsonObj.get("stream_description").isJsonNull() && !jsonObj.get("stream_description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stream_description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stream_description").toString()));
      }
      if (!jsonObj.get("stream_key").isJsonNull() && !jsonObj.get("stream_key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stream_key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stream_key").toString()));
      }
      if (!jsonObj.get("stream_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stream_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stream_mode").toString()));
      }
      if (!jsonObj.get("stream_password").isJsonNull() && !jsonObj.get("stream_password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stream_password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stream_password").toString()));
      }
      // validate the required field `stream_privacy`
      LiveEventRecurringStreamPrivacy.validateJsonObject(jsonObj.getAsJsonObject("stream_privacy"));
      if (!jsonObj.get("stream_title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stream_title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stream_title").toString()));
      }
      if (!jsonObj.get("time_zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `time_zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("time_zone").toString()));
      }
      if (!jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      // validate the required field `user`
      User.validateJsonObject(jsonObj.getAsJsonObject("user"));
      if (!jsonObj.get("view_link").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `view_link` to be a primitive type in the JSON string but got `%s`", jsonObj.get("view_link").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("webinar") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("webinar").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `webinar` to be an array in the JSON string but got `%s`", jsonObj.get("webinar").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LiveEventRecurring.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LiveEventRecurring' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LiveEventRecurring> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LiveEventRecurring.class));

       return (TypeAdapter<T>) new TypeAdapter<LiveEventRecurring>() {
           @Override
           public void write(JsonWriter out, LiveEventRecurring value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public LiveEventRecurring read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             LiveEventRecurring instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LiveEventRecurring given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LiveEventRecurring
  * @throws IOException if the JSON string is invalid with respect to LiveEventRecurring
  */
  public static LiveEventRecurring fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LiveEventRecurring.class);
  }

 /**
  * Convert an instance of LiveEventRecurring to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

